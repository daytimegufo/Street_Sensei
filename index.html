<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Street Sensei Map Challenge Game</title>
    <link rel="stylesheet" href="libs/leaflet.css" />
    <script>
        // Simplified library load check
        window.checkLibrariesLoaded = function() {
            return {
                leaflet: typeof L !== 'undefined',
                turf: typeof turf !== 'undefined'
            };
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/fireworks-js@2.10.8/dist/index.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .header {
            background: #2d2d2d;
            padding: 0.75rem 1rem;
            border-bottom: 2px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 70px;
            position: relative;
        }

        @media (max-width: 768px) {
            .header {
                height: 60px;
                padding: 0.5rem;
            }
        }

        .title {
            font-size: 1.25rem;
            font-weight: bold;
            color: #4CAF50;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 1rem;
            }
        }

        .stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.85rem;
        }

        @media (max-width: 768px) {
            .stats {
                gap: 0.75rem;
                font-size: 0.75rem;
                flex-wrap: wrap;
            }
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4CAF50;
        }

        @media (max-width: 768px) {
            .stat-value {
                font-size: 0.95rem;
            }
        }

.menu-toggle {
            display: none;
            background: #4CAF50;
            border: none;
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.5rem;
            width: 2.5rem;
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
                font-size: 1.2rem;
            }
        }

        @media (min-width: 769px) {
            .menu-toggle {
                display: block;
            }
        }

        .game-container {
            display: flex;
            height: calc(100vh - 70px);
        }

        @media (max-width: 768px) {
            .game-container {
                height: calc(100vh - 60px - 60px);
                flex-direction: column;
            }
        }

        .sidebar {
            width: 380px;
            background: #2d2d2d;
            border-right: 2px solid #444;
            padding: 1.25rem;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 60px;
                left: 0;
                width: 100vw;
                height: calc(100vh - 60px - 60px);
                z-index: 1000;
                transform: translateX(-100%);
                padding: 1rem;
            }

            .sidebar.open {
                transform: translateX(0);
            }
        }

        @media (min-width: 769px) {
            .sidebar.closed {
                display: none;
            }
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
            background: #333;
            touch-action: manipulation;
        }

        /* Leaflet tile layer optimization */
        .leaflet-tile-container {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        .leaflet-tile {
            max-width: none !important;
            max-height: none !important;
            border: none !important;
            background: transparent !important;
            transition: opacity 0.3s ease;
        }

        .leaflet-tile-loaded {
            opacity: 1 !important;
        }

        .leaflet-tile-loading {
            opacity: 0.5 !important;
        }

        /* Hide broken tiles */
        .leaflet-tile[src=""], 
        .leaflet-tile[src*="data:image/gif"] {
            display: none !important;
            visibility: hidden !important;
        }

        /* Prevent tile flickering */
        .leaflet-fade-anim .leaflet-tile {
            transition: opacity 0.3s ease !important;
        }

        .leaflet-zoom-anim .leaflet-tile {
            transition: none !important;
        }

        .setup-section {
            margin-bottom: 1.5rem;
        }

        .setup-section h3 {
            margin-bottom: 0.75rem;
            color: #4CAF50;
            border-bottom: 1px solid #444;
            padding-bottom: 0.5rem;
            font-size: 1rem;
        }

        .form-group {
            margin-bottom: 0.75rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.9rem;
        }

        select, input, button, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #555;
            border-radius: 6px;
            background: #3d3d3d;
            color: #fff;
            font-size: 0.9rem;
            outline: none;
            transition: border-color 0.2s;
        }

        @media (max-width: 768px) {
            select, input, button, textarea {
                padding: 1rem;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px; /* Touch-friendly size */
            }
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        button:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #666 !important;
            cursor: not-allowed;
            opacity: 0.7;
        }

        button.loading {
            pointer-events: none;
        }

        .challenge-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #444;
        }

        .question-display {
            background: #3d3d3d;
            padding: 1.25rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            text-align: center;
        }

        .question-text {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .question-type {
            font-size: 0.85rem;
            color: #aaa;
        }

        .question-progress {
            font-size: 0.85rem;
            color: #4CAF50;
            margin-top: 0.5rem;
        }

        .timer {
            font-size: 1.75rem;
            font-weight: bold;
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 1rem;
        }

        .distance-display {
            background: #3d3d3d;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            text-align: center;
        }

        .results-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(45, 45, 45, 0.95);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            min-width: 300px;
            backdrop-filter: blur(10px);
            max-width: 90vw;
        }

        .score-display {
            font-size: 1.75rem;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 1rem;
        }

        .multiple-choice {
            display: grid;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .choice-button {
            padding: 1rem;
            background: #3d3d3d;
            border: 1px solid #555;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }

        @media (max-width: 768px) {
            .choice-button {
                padding: 1.25rem;
                font-size: 1rem;
                min-height: 48px;
            }
        }

        .choice-button:hover {
            background: #4d4d4d;
            border-color: #4CAF50;
        }

        .choice-button.correct {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        .choice-button.incorrect {
            background: #f44336;
            border-color: #f44336;
        }

        .mode-tabs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            margin-bottom: 1rem;
            gap: 0.25rem;
        }

        .mode-tab {
            padding: 0.5rem;
            background: #3d3d3d;
            border: 1px solid #555;
            color: #aaa;
            cursor: pointer;
            font-size: 0.8rem;
            text-align: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        /* Disable mode-tab visually when not ready */
        .mode-tab.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .mode-tab {
                padding: 0.75rem 0.5rem;
                font-size: 0.75rem;
                min-height: 48px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        .mode-tab.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .blinking {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .hidden {
            display: none !important;
        }

        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .map-control-btn {
            width: 44px;
            height: 44px;
            background: rgba(45, 45, 45, 0.9);
            border: 2px solid #4CAF50;
            color: #4CAF50;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        @media (max-width: 768px) {
            .map-control-btn {
                width: 50px;
                height: 50px;
                font-size: 1.4rem;
            }
            .map-controls {
                display: none;
            }
        }

        .map-control-btn:hover {
            background: #4CAF50;
            color: white;
        }

        .layer-toggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(45, 45, 45, 0.9);
            border: 2px solid #4CAF50;
            color: #4CAF50;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        @media (max-width: 768px) {
            .layer-toggle {
                bottom: 70px;
                font-size: 0.75rem;
                padding: 1rem;
                min-height: 48px;
            }
        }

        .layer-toggle:hover {
            background: #4CAF50;
            color: white;
        }

        .start-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(254, 252, 252, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.2rem;
            padding: 0.2rem;
            z-index: 950;
            width: 30rem;
            margin: 0 auto;
        }

        .start-controls select,
        .start-controls button {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            width: 15rem;
        }

        @media (max-width: 768px) {
            .start-controls {
                width: 100%;
                height: 60px;
                padding: 0.5rem;
            }

            .start-controls select,
            .start-controls button {
                font-size: 1rem;
                width: 48%;
            }
        }

        .debug-info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 1000;
            max-width: 90vw;
            display: none !important;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: middle;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message, .warning-message, .success-message, .info-message {
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .error-message {
            background: #f44336;
            color: white;
        }

        .warning-message {
            background: #ff9800;
            color: white;
        }

        .success-message {
            background: #4CAF50;
            color: white;
        }

        .info-message {
            background: #2196F3;
            color: white;
        }

        /* Advanced Settings Panel */
        .advanced-settings {
            margin-top: 1rem;
            padding: 1rem;
            background: #333;
            border-radius: 8px;
            border: 1px solid #555;
        }

        .advanced-settings h3 {
            color: #ff9800;
            margin-bottom: 1rem;
            font-size: 1rem;
            border-bottom: 1px solid #555;
            padding-bottom: 0.5rem;
        }

        .advanced-settings h4 {
            color: #4CAF50;
            margin: 1rem 0 0.5rem 0;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.25rem;
        }

        .editor-section {
            margin-bottom: 1.5rem;
        }

        .point-list {
            max-height: 150px;
            overflow-y: auto;
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.5rem;
        }

        .point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem;
            margin: 0.25rem 0;
            background: #4d4d4d;
            border-radius: 4px;
        }

        .point-coords {
            font-size: 0.8rem;
            color: #ccc;
        }

        .point-remove {
            background: #f44336;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.7rem;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            width: 100%;
            padding: 0.75rem;
            background: #2196F3;
            color: white;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .file-input-label:hover {
            background: #1976D2;
        }

        .problem-list {
            max-height: 200px;
            overflow-y: auto;
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.5rem;
        }

        .problem-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            margin: 0.25rem 0;
            background: #4d4d4d;
            border-radius: 4px;
        }

        .problem-name {
            font-weight: bold;
            color: #4CAF50;
        }

        .problem-info {
            font-size: 0.8rem;
            color: #ccc;
        }

        .problem-actions {
            display: flex;
            gap: 0.25rem;
        }

        .btn-small {
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            border-radius: 3px;
        }

        .btn-edit {
            background: #ff9800;
        }

        .btn-delete {
            background: #f44336;
        }

        .current-location-btn {
            background: #2196F3;
            margin-top: 0.5rem;
        }

        .current-location-btn:hover {
            background: #1976D2;
        }

        /* Location Services */
        .location-status {
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            text-align: center;
        }

        .location-status.success {
            background: #4CAF50;
            color: white;
        }

        .location-status.error {
            background: #f44336;
            color: white;
        }

        .location-status.pending {
            background: #ff9800;
            color: white;
        }

        /* Hide advanced settings on mobile */
        @media (max-width: 768px) {
            .advanced-settings {
                display: none !important;
            }
            
            /* Hide advanced tools button on mobile */
            #toggle-settings {
                display: none;
            }
        }

        /* Touch optimization */
        @media (hover: none) and (pointer: coarse) {
            .choice-button:hover,
            .mode-tab:hover,
            .map-control-btn:hover,
            .layer-toggle:hover {
                background: inherit;
                color: inherit;
                border-color: inherit;
                transform: none;
            }
        }

        /* タイマー表示を統一（サイドバー内から移動） */
        .timer-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
            margin: 0 1rem;
            min-width: 50px;
            text-align: center;
        }

        .timer-display.warning {
            color: #ff9800;
        }

        .timer-display.danger {
            color: #ff6b6b;
            animation: blink 1s infinite;
        }

        /* モバイルでの調整 */
        @media (max-width: 768px) {
            .timer-display {
                font-size: 1.2rem;
                margin: 0 0.5rem;
            }
        }

        /* Mobile Game Overlay - ゲーム中の地図上表示 */
        .mobile-game-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 900;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .mobile-game-overlay.active {
                display: block;
            }
        }

        /* タイマーとスコア - 地図右上 */
        .mobile-game-stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(45, 45, 45, 0.9);
            border-radius: 8px;
            padding: 0.5rem;
            pointer-events: auto;
            min-width: 80px;
            text-align: center;
        }

        .mobile-timer {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 0.25rem;
        }

        .mobile-timer.warning {
            color: #ff9800;
        }

        .mobile-timer.danger {
            color: #ff6b6b;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .mobile-score {
            font-size: 0.6rem;
            color: #ccc;
        }
    
        /* ゲーム中はサイドバーを完全に隠す */
        .game-playing .sidebar {
            transform: translateX(-100%) !important;
        }

        /* ゲーム中のヘッダー簡素化 */
        @media (max-width: 768px) {
            .game-playing .header {
                height: 60px;
                padding: 0.5rem;
            }

            .game-playing .header .title {
                display: none;
            }

            .game-playing .game-container {
                height: calc(100vh - 60px);
            }

            .game-playing .mobile-controls {
                display: none;
            }
        }

        /* PC用ゲーム中のUI */
        @media (min-width: 769px) {
            .game-playing .sidebar {
                display: none;
            }

            .game-playing .game-container {
                height: calc(100vh - 70px);
            }
        }

        /* 距離表示 - 地図左下 */
        .mobile-distance-overlay {
            position: absolute;
            bottom: 80px;
            left: 10px;
            background: rgba(45, 45, 45, 0.9);
            color: #fff;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.9rem;
            pointer-events: auto;
            max-width: 200px;
        }

        /* 統一された問題表示 - 地図左下 */
        .game-question-overlay {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background: rgba(45, 45, 45, 0.95);
            color: #fff;
            padding: 1rem;
            border-radius: 12px;
            max-width: 350px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 950;
        }

        .game-question-type {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 0.5rem;
        }

        .game-question-text {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 1rem;
            line-height: 1.4;
        }

        .game-question-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .game-question-actions button {
            flex: 1;
            padding: 0.75rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-answer {
            background: #ff9800;
            color: white;
        }

        .btn-next {
            background: #4CAF50;
            color: white;
        }

        .btn-end {
            background: #f44336;
            color: white;
        }

        /* 5択選択肢 - 地図左下（Reverseモード用） */
        .game-choices-overlay {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background: rgba(45, 45, 45, 0.95);
            color: #fff;
            padding: 1rem;
            border-radius: 12px;
            max-width: 350px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 950;
        }

        .game-choices-grid {
            display: grid;
            gap: 0.5rem;
        }

        .mobile-choice-btn {
            background: rgba(61, 61, 61, 0.9);
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 0.75rem;
            font-size: 0.9rem;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mobile-choice-btn:hover {
            background: rgba(77, 77, 77, 0.9);
            border-color: #4CAF50;
        }

        .mobile-choice-btn.correct {
            background: rgba(76, 175, 80, 0.9);
            border-color: #4CAF50;
        }

        .mobile-choice-btn.incorrect {
            background: rgba(244, 67, 54, 0.9);
            border-color: #f44336;
        }

        /* --- Answer reveal animations --- */
        .glow-line {
            opacity: 0;
            transition: opacity 0.8s;
            filter: drop-shadow(0 0 10px #0f0);
        }

        .pulse-red {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f44336;
            border: 2px solid white;
            animation: pulse-scale 1s infinite;
        }

        @keyframes pulse-scale {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }
        /* --- Result modal --- */
        #result-modal {
            position: absolute;
            top: 10px;
            left: 10px;
            transform: none;
            background: rgba(45,45,45,0.95);
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
            min-width: 130px;
        }
        .score-circle {
            width: 60px;
            height: 60px;
            margin: 0 auto 0.5rem;
        }
        .score-circle circle {
            fill: none;
            stroke-width: 10;
            stroke-linecap: round;
            stroke-dasharray: 282.6;
            stroke-dashoffset: 282.6;
            transition: stroke-dashoffset 1s ease;
        }
        .score-circle.green circle { stroke: #0a0; }
        .score-circle.orange circle { stroke: #f80; }
        .score-circle.red circle { stroke: #a00; }

        /* Loading overlay */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            pointer-events: all;
        }

        .loader-content {
            text-align: center;
            color: #fff;
        }

        .loader-content .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        .loader-content .message {
            font-size: 1.2em;
            line-height: 1.4;
        }

        #reverse-feedback-popup {
            animation: fadein 0.5s;
        }

        @keyframes fadein {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        #reverse-feedback-popup {
            animation: fadein 0.5s;
        }

        @keyframes fadein {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-toggle" id="menu-toggle">☰</button>
        <div class="title">Street Sensei</div>
        <div class="timer-display hidden" id="header-timer">30</div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="score">0</div>
                <div>Score</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="streak">0</div>
                <div>Streak</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="total-questions">0</div>
                <div>Questions</div>
            </div>
            <div class="stat-item" id="speedrun-progress-container" style="display:none;">
                <div class="stat-value" id="speedrun-progress">0/5</div>
                <div id="speedrun-remaining">残り: 5 問</div>
            </div>
            <div class="stat-item" id="speedrun-timer-container" style="display:none;">
                <div class="stat-value" id="speedrun-timer">00:00</div>
                <div>Time</div>
            </div>
        </div>
    </div>

    <div class="game-container">
        <div class="sidebar" id="sidebar">
            <div class="mode-tabs">
                <div class="mode-tab disabled" data-mode="street">Street</div>
                <div class="mode-tab" data-mode="facility">Facility</div>
                <div class="mode-tab" data-mode="intersection">Intersection</div>
                <div class="mode-tab" data-mode="reverse">Reverse</div>
            </div>
            <!-- Game Section (always visible) -->

            <div class="setup-section" id="registration-preview" style="display:none;">
                <h3>登録施設リスト</h3>
                <div id="registration-list"></div>
            </div>

            <div class="setup-section">
                <h3>出題範囲</h3>
                <div class="form-group">
                    <label for="location">Center Location</label>
                    <input type="text" id="location" placeholder="Enter city or coordinates" value="Tokyo, Japan">
                    <button id="update-location">Update Location</button>
                    <button id="get-current-location" class="current-location-btn">📍 Use Current Location</button>
                    <div id="location-status" class="location-status hidden"></div>
                </div>
                <div class="form-group">
                    <label for="range">Range: <span id="range-display">5 km</span></label>
                    <input type="range" id="range" min="1" max="50" value="5">
                </div>
            </div>

            <div class="setup-section">
                <h3>Difficulty</h3>
                <div class="form-group">
                    <select id="difficulty">
                        <option value="tourist">Tourist (Easy)</option>
                        <option value="resident">Resident (Medium)</option>
                        <option value="taxi-driver">Taxi Driver (Hard)</option>
                    </select>
                </div>
            </div>

            <div class="setup-section">
                <h3>問題ソース</h3>
                <div class="form-group">
                    <select id="problem-source">
                        <option value="mixed">ミックス (OSM + カスタム)</option>
                        <option value="osm-only">OSMデータのみ</option>
                        <option value="custom-only">カスタム問題のみ</option>
                    </select>
                    <div id="source-ratio-control" style="margin-top: 0.5rem;">
                        <label for="osm-custom-ratio" style="font-size: 0.8rem;">
                            OSM : カスタム比率: <span id="ratio-display">70:30</span>
                        </label>
                        <input type="range" id="osm-custom-ratio" min="0" max="100" value="70" style="margin-top: 0.25rem;">
                    </div>
                </div>
            </div>

            <div class="setup-section">
                <h3>Data Source</h3>
                <div class="form-group">
                    <label for="region-select">Regional Network</label>
                    <select id="region-select">
                        <option value="south-kanto">南関東全域 (Complete Network)</option>
                        <option value="tokyo-center">東京都心 (Center Only)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="loading-strategy">Loading Strategy</label>
                    <select id="loading-strategy">
                        <option value="immediate">⚡ 即座開始 (Fast Start)</option>
                        <option value="balanced">⚖️ バランス型 (Balanced)</option>
                        <option value="complete">🔄 完全読み込み (Complete)</option>
                    </select>
                    <small style="color: #aaa; font-size: 0.75rem; display: block; margin-top: 0.25rem;">
                        即座開始: 10秒で開始可能、他は必要時に読み込み
                    </small>
                </div>
            </div>

            <div class="setup-section">
                <button id="load-street-data" style="background: #ff9800; font-size: 0.85rem; margin-top: 0.5rem;">🗺️ Load Regional Roads</button>
                <button id="load-facility-data" style="background: #2196F3; font-size: 0.85rem; margin-top: 0.5rem;">🏥 Load Facility Data</button>
                <button id="load-intersection-data" style="background: #9C27B0; font-size: 0.85rem; margin-top: 0.5rem;">🚦 Load Intersection Data</button>
                <button id="toggle-settings" style="background: #666; font-size: 0.85rem; margin-top: 0.5rem;">🔧 Show Advanced Tools</button>
                <div id="data-status" style="margin-top: 0.5rem; padding: 0.5rem; background: #5a2d2d; border-radius: 4px; font-size: 0.8rem; color: white;">
                    ⚠️ Street mode requires regional data - click above to load complete road network
                </div>
            </div>

            <!-- Advanced Settings Panel (Hidden by default) -->
            <div class="advanced-settings hidden" id="advanced-settings">
                <div class="setup-section">
                    <h3>🔧 Advanced Tools (PC Only)</h3>
                    
                    <!-- Problem Editor -->
                    <div class="editor-section">
                        <h4>Problem Editor</h4>
                        <div class="form-group">
                            <label for="problem-name">Problem Name</label>
                            <input type="text" id="problem-name" placeholder="Enter street/facility name">
                        </div>
                        <div class="form-group">
                            <label for="problem-type">Problem Type</label>
                            <select id="problem-type">
                                <option value="street">Street</option>
                                <option value="facility">Facility</option>
                                <option value="intersection">Intersection</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="problem-description">Description</label>
                            <textarea id="problem-description" placeholder="Brief description of the location" rows="2"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="problem-importance">Importance (1-100)</label>
                            <input type="range" id="problem-importance" min="1" max="100" value="70">
                            <span id="importance-display">70</span>
                        </div>
                        <div class="form-group">
                            <label for="problem-difficulty">難易度設定</label>
                            <select id="problem-difficulty-mode">
                                <option value="auto">自動判定 (Importanceから)</option>
                                <option value="manual">手動設定</option>
                            </select>
                            <select id="problem-difficulty" style="margin-top: 0.5rem; display: none;">
                                <option value="tourist">Tourist (Easy)</option>
                                <option value="resident">Resident (Medium)</option>
                                <option value="taxi-driver">Taxi Driver (Hard)</option>
                            </select>
                            <div id="auto-difficulty-display" style="margin-top: 0.5rem; font-size: 0.8rem; color: #4CAF50;">
                                自動判定: Resident (Medium)
                            </div>
                        </div>
                        
                        <h4>Location Points</h4>
                        <p style="font-size: 0.8rem; color: #aaa; margin-bottom: 0.5rem;">
                            Click on the map to add points for this problem
                        </p>
                        <div id="current-points" class="point-list">
                            <div style="text-align: center; color: #666;">No points added yet</div>
                        </div>
                        <button id="clear-points" style="background: #f44336; margin-top: 0.5rem;">Clear All Points</button>
                        
                        <div style="margin-top: 0.5rem;">
                            <button id="save-problem" style="background: #4CAF50;">Save Problem</button>
                            <button id="cancel-edit" style="background: #666; margin-top: 0.25rem;">Cancel</button>
                        </div>
                        
                        <h4>Custom Problems</h4>
                        <div id="custom-problems" class="problem-list">
                            <div style="text-align: center; color: #666;">No custom problems yet</div>
                        </div>
                    </div>

                    <!-- KML Import -->
                    <div class="editor-section">
                        <h4>Import KML Data</h4>
                        <div class="form-group">
                            <div class="file-input-wrapper">
                                <input type="file" id="kml-file" class="file-input" accept=".kml,.kmz">
                                <label for="kml-file" class="file-input-label">📁 Choose KML File</label>
                            </div>
                        </div>
                        <div id="import-status" class="hidden"></div>
                        
                        <h4>Import Instructions</h4>
                        <div style="font-size: 0.8rem; color: #ccc; line-height: 1.4;">
                            <p><strong>Supported formats:</strong> KML files with LineString or Point geometries</p>
                            <p><strong>Required fields:</strong> Name (required), Description (optional)</p>
                            <p><strong>How to create KML:</strong></p>
                            <ul style="margin-left: 1rem; margin-top: 0.5rem;">
                                <li>Use Google My Maps to create custom maps</li>
                                <li>Draw lines for streets or place markers for facilities</li>
                                <li>Export as KML file</li>
                                <li>Import here to use in the game</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="challenge-section hidden" id="challenge-section">
                <div class="timer" id="timer">30</div>
                
                <div class="question-display">
                    <div class="question-text" id="question-text">Click on the map to locate:</div>
                    <div class="question-type" id="question-type">Street Challenge</div>
                    <div class="question-progress" id="question-progress"></div>
                </div>

                <div class="multiple-choice hidden" id="multiple-choice"></div>

                <div class="distance-display hidden" id="distance-display">
                    <div>Distance: <span id="distance">-</span></div>
                    <div>Accuracy: <span id="accuracy">-</span></div>
                </div>

                <button id="next-question" class="hidden">Next Question</button>
                <button id="show-answer" class="hidden" style="background: #ff9800;">Show Answer</button>
                <button id="end-game" style="background: #f44336;">End Game</button>
            </div>
        </div>

        <div class="map-container">
            <div id="map"></div>
            <div id="loading-overlay" style="display:none;">
              <div class="loader-content">
                <div class="spinner"></div>
                <div class="message">データを読み込み中です…<br>しばらくお待ちください</div>
              </div>
            </div>
            <div id="result-modal" class="hidden">
                <div class="score-circle" id="score-circle">
                    <svg width="60" height="60">
                        <circle cx="30" cy="30" r="25"></circle>
                    </svg>
                </div>
                <p id="score-text">スコア: <span>0</span>%</p>
                <p id="dist-text">距離: <span>0</span>m</p>
            </div>

            <!-- Mobile Game Overlay - モバイルゲーム用オーバーレイ -->
            <div class="mobile-game-overlay" id="mobile-game-overlay">
                <!-- 5択選択肢 -->
                <div class="mobile-choices-overlay hidden" id="mobile-choices-overlay">
                    <div class="mobile-choices-grid" id="mobile-choices-grid">
                        <!-- 動的に生成される -->
                    </div>
                </div>

                <!-- 結果表示 -->
                <div class="mobile-distance-overlay hidden" id="mobile-distance-overlay">
                    <div>距離: <span id="mobile-distance">-</span></div>
                    <div>精度: <span id="mobile-accuracy">-</span></div>
                </div>
            </div>

            <!-- 統一された問題表示エリア（PC向け） -->
            <div class="game-question-overlay hidden" id="game-question-overlay">
                <div class="game-question-type" id="game-question-type">Streetチャレンジ</div>
                <div class="game-question-text" id="game-question-text">地図をタップして場所を特定してください</div>
                <div class="game-question-actions">
                    <button class="btn-answer" id="game-btn-answer">Show Answer</button>
                    <button class="btn-next" id="game-btn-next">Next</button>
                    <button class="btn-end" id="game-btn-end">End</button>
                </div>
            </div>

            <!-- Reverseモード用選択肢エリア（PC向け） -->
            <div class="game-choices-overlay hidden" id="game-choices-overlay">
                <div class="game-choices-grid" id="game-choices-grid"></div>
            </div>
            
            <div class="map-controls">
                <div class="map-control-btn" id="zoom-in" title="Zoom In">+</div>
                <div class="map-control-btn" id="zoom-out" title="Zoom Out">−</div>
            </div>
            
            <div class="layer-toggle" id="toggle-labels" title="街路名表示切替（ゲーム中は次の問題で自動的に非表示に戻ります）">
                街路名表示/非表示
            </div>

            <div class="results-overlay hidden" id="results-overlay">
                <h2>Game Complete!</h2>
                <div class="score-display" id="final-score">Score: 0</div>
                <div id="final-stats"></div>
                <button onclick="resetGame()">Play Again</button>
            </div>

            <div class="debug-info" id="debug-info">Loading map...</div>

            <div class="start-controls" id="start-controls">
               <select id="game-mode-select">
                    <option value="street" disabled>Street</option>
                    <option value="facility">Facility</option>
                    <option value="intersection">Intersection</option>
                    <option value="reverse">Reverse</option>
                    <option value="geotextbook">地理教本施設モード</option>
                    <!-- NEW: curated intersections mode -->
                    <option value="geotextbook-intersection">地理教本交差点</option>
                </select>
                <!-- CHANGED: 施設/交差点どちらの地理教本でも共用 -->
                <select id="geotextbook-area-select" style="display:none;">
                    <option value="tokyo23">東京23区武三</option>
                </select>
                <!-- CHANGED: 施設/交差点どちらの地理教本でも共用 -->
                <select id="geotextbook-play-order" style="display:none;">
                    <option value="random">ランダム</option>
                    <option value="registration">登録順</option>
                </select>
                <input type="number" id="speedrun-target" min="1" value="5" style="display:none; width:4rem;" title="連続目標問数">
                <input type="number" id="speedrun-tolerance" step="0.1" min="1" value="2.0" style="display:none; width:4rem;" title="許容距離倍率">
                <button id="start-game">Start Game</button>
            </div>
        </div>
    </div>

    <script src="libs/leaflet.js" defer></script>
    <script src="libs/turf.min.js" defer></script>
    <script>
        // Use a CORS-enabled Overpass mirror for client-side requests
        const OVERPASS_URL = 'https://overpass.openstreetmap.fr/api/interpreter';
        // Deferred loading for Street mode
        let roadCache = null;
        let locationPermissionDenied = false;
        const KML_BASE_URL = "https://raw.githubusercontent.com/daytimegufo/Street_Sensei/New-map/kml_files/";
        const KML_INDEX_URL = "https://api.github.com/repos/daytimegufo/Street_Sensei/contents/kml_files?ref=New-map";

        /** Load Street data on-demand and enable UI when ready */
        async function prepareStreetMode() {
            if (roadCache) return;
            showLoading();
            try {
                const region = document.getElementById('region-select') ? document.getElementById('region-select').value : 'south-kanto';
                const strategy = document.getElementById('loading-strategy') ? document.getElementById('loading-strategy').value : 'immediate';
                await loadRegionalRoadsOptimized(region, strategy);
                roadCache = gameState.streetData;
                const streetTab = document.querySelector('.mode-tab[data-mode="street"]');
                if (streetTab) streetTab.classList.remove('disabled');
                const opt = document.querySelector('#game-mode-select option[value="street"]');
                if (opt) opt.disabled = false;
            } finally {
                hideLoading();
            }
        }
        function log(message) {
            console.log(message);
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo) {
                const timestamp = new Date().toLocaleTimeString();
                debugInfo.innerHTML = `[${timestamp}] ${message}`;
                debugInfo.style.display = 'block';
                
                if (message.includes('successfully') || message.includes('ready')) {
                    setTimeout(() => {
                        debugInfo.style.display = 'none';
                    }, 3000);
                }
                
                if (message.includes('Error') || message.includes('Failed')) {
                    debugInfo.style.background = '#f44336';
                    debugInfo.style.color = 'white';
                } else if (message.includes('successfully') || message.includes('ready')) {
                    debugInfo.style.background = '#4CAF50';
                    debugInfo.style.color = 'white';
                } else {
                    debugInfo.style.background = 'rgba(0,0,0,0.8)';
                    debugInfo.style.color = 'white';
                }
            }
        }

        // Enhanced library loading check for Safari
        function checkLibraryLoading() {
            const checks = {
                leaflet: typeof L !== 'undefined',
                turf: typeof turf !== 'undefined',
                dom: document.readyState === 'complete'
            };
            
            log(`Library check: Leaflet=${checks.leaflet}, Turf=${checks.turf}, DOM=${checks.dom}`);
            
            // Safari specific debugging
            if (navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome')) {
                log('Safari detected - applying Safari-specific optimizations');
            }
            
            return checks;
        }

        // KML loading functions
        async function fetchKmlIndex() {
            try {
                const response = await fetch(KML_INDEX_URL);
                const data = await response.json();
                const kmlMap = {};
                data.forEach(file => {
                    if (file.name && file.name.endsWith('.kml')) {
                        const name = file.name.replace('.kml', '');
                        kmlMap[name] = file.download_url;
                    }
                });
                log(`KML index loaded: ${Object.keys(kmlMap).length} files`);
                return kmlMap;
            } catch (err) {
                log('Failed to load KML index: ' + err.message);
                return {};
            }
        }

        function extractBaseStreetName(name) {
            // "昭和通り（Showa-dori）" → "昭和通り"
            // "中央通り；万世橋" → "中央通り"
            return name.split(/[（(;；]/)[0].trim();
        }

        // Normalize KML filename (e.g., "昭和通り_merged" → "昭和通り")
        function extractKmlBaseName(filename) {
            return filename.replace(/_merged$/, '').trim();
        }

        async function loadKmlIfExists(streetName, kmlMap) {
            const baseName = extractBaseStreetName(streetName);
            let matchKey = null;

            // 1) Prefer exactly matched "_merged" file
            if (kmlMap[baseName + '_merged']) {
                matchKey = baseName + '_merged';
            // 2) Next, exact match without suffix
            } else if (kmlMap[baseName]) {
                matchKey = baseName;
            // 3) Fallback to partial matching (old behavior)
            } else {
                matchKey = Object.keys(kmlMap || {}).find(k => {
                    const kmlBase = extractKmlBaseName(k);
                    return (
                        baseName === kmlBase ||
                        baseName.startsWith(kmlBase) ||
                        kmlBase.startsWith(baseName) ||
                        baseName.includes(kmlBase) ||
                        kmlBase.includes(baseName)
                    );
                });
            }

            if (!matchKey) return null;
            try {

                const res = await fetch(kmlMap[matchKey]);
                const kmlText = await res.text();
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                const lines = kmlDoc.getElementsByTagName('LineString');
                const segments = [];

                for (let i = 0; i < lines.length; i++) {
                    const coordsText = lines[i].getElementsByTagName('coordinates')[0]?.textContent;
                    if (coordsText) {
                        const coords = parseCoordinateString(coordsText);
                        if (coords.length > 0) segments.push(coords);
                    }
                }

                if (segments.length > 0) {
                    log(`✅ KML loaded for ${streetName} → ${matchKey}`);
                    return { points: segments };
                }

            } catch (err) {
                log('❌ Failed to load KML for ' + streetName + ': ' + err.message);
            }

            return null;
        }

        // Mobile-specific initialization with Safari fixes
        function initializeForMobile() {
            log('Initializing for mobile device...');
            
            // Safari specific fixes
            if (navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome')) {
                log('Applying Safari mobile optimizations...');
                
                // Prevent Safari zoom on input focus
                document.addEventListener('touchstart', function(e) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                        e.target.style.fontSize = '16px';
                    }
                });
                
                // Force hardware acceleration for Safari
                document.body.style.webkitTransform = 'translateZ(0)';
                document.body.style.webkitBackfaceVisibility = 'hidden';
            }
            
            if (!document.querySelector('meta[name="apple-mobile-web-app-capable"]')) {
                const meta = document.createElement('meta');
                meta.name = 'apple-mobile-web-app-capable';
                meta.content = 'yes';
                document.head.appendChild(meta);
            }
            
            // Prevent bounce scrolling
            document.body.style.overscroll = 'none';
            document.body.style.webkitOverflowScrolling = 'touch';
            
            const mapContainer = document.getElementById('map');
            if (mapContainer) {
                mapContainer.style.transform = 'translateZ(0)';
                mapContainer.style.webkitTransform = 'translateZ(0)';
                mapContainer.style.webkitBackfaceVisibility = 'hidden';
            }
            
            log('Mobile initialization complete');
        }

        // Mobile Game UI Functions - 統一されたUIのため簡略化
        function initMobileGameUI() {
            log('Mobile game UI initialized with unified interface');
        }

        function showMobileGameUI() {
            log('Showing mobile game UI...');
            
            const overlay = document.getElementById('mobile-game-overlay');
            const body = document.body;
            const questionOverlay = document.getElementById('game-question-overlay');
            const headerTimer = document.getElementById('header-timer');
            
            if (overlay) {
                overlay.classList.add('active');
            }
            
            if (questionOverlay) {
                questionOverlay.classList.remove('hidden');
            }
            
            if (headerTimer) {
                headerTimer.classList.remove('hidden');
            }
            
            // Add game-playing class to body for CSS targeting
            body.classList.add('game-playing');
            
            updateMobileGameStats();
        }

        function hideMobileGameUI() {
            const overlay = document.getElementById('mobile-game-overlay');
            const body = document.body;
            const questionOverlay = document.getElementById('game-question-overlay');
            const choicesOverlay = document.getElementById('game-choices-overlay');
            const headerTimer = document.getElementById('header-timer');
            
            if (overlay) {
                overlay.classList.remove('active');
            }
            
            if (questionOverlay) {
                questionOverlay.classList.add('hidden');
            }
            
            if (choicesOverlay) {
                choicesOverlay.classList.add('hidden');
            }
            
            if (headerTimer) {
                headerTimer.classList.add('hidden');
            }
            
            body.classList.remove('game-playing');
        }

        function updateMobileGameStats() {
            if (window.innerWidth > 768) return;
            
            // Update mobile stats display
            const mobileScore = document.getElementById('mobile-score');
            const mobileStreak = document.getElementById('mobile-streak');
            const mobileTimer = document.getElementById('mobile-timer');
            
            if (mobileScore) mobileScore.textContent = gameState.score;
            if (mobileStreak) mobileStreak.textContent = gameState.streak;
            if (mobileTimer) {
                mobileTimer.textContent = gameState.timer;
                
                // Update timer appearance
                mobileTimer.classList.remove('warning', 'danger');
                if (gameState.timer <= 5) {
                    mobileTimer.classList.add('danger');
                } else if (gameState.timer <= 10) {
                    mobileTimer.classList.add('warning');
                }
            }
        }

        function updateMobileQuestion(questionText, questionType) {
            const gameQuestionText = document.getElementById('game-question-text');
            const gameQuestionType = document.getElementById('game-question-type');
            
            if (gameQuestionText) {
                gameQuestionText.textContent = questionText;
            }
            if (gameQuestionType) {
                gameQuestionType.textContent = questionType;
            }
        }

        function showMobileChoices(choices, hideQuestion = true) {
            const questionOverlay = document.getElementById('game-question-overlay');
            const choicesOverlay = document.getElementById('game-choices-overlay');
            const grid = document.getElementById('game-choices-grid');
            
            if (!choicesOverlay || !grid) return;

            if (questionOverlay && hideQuestion) {
                questionOverlay.classList.add('hidden');
            }
            
            // Clear existing choices
            grid.innerHTML = '';
            
            // Create choice buttons
            choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'mobile-choice-btn';
                button.textContent = choice.name;
                button.onclick = () => handleMobileChoiceClick(choice, button);
                grid.appendChild(button);
            });

            choicesOverlay.classList.remove('hidden');
        }

        function hideMobileChoices(showQuestion = true) {
            const choicesOverlay = document.getElementById('game-choices-overlay');
            const questionOverlay = document.getElementById('game-question-overlay');

            if (choicesOverlay) {
                choicesOverlay.classList.add('hidden');
            }

            if (questionOverlay) {
                if (showQuestion && gameState.isPlaying) {
                    questionOverlay.classList.remove('hidden');
                } else {
                    questionOverlay.classList.add('hidden');
                }
            }
        }

        function handleMobileChoiceClick(selectedChoice, button) {
            // Disable all buttons
            document.querySelectorAll('.mobile-choice-btn').forEach(btn => {
                btn.disabled = true;
                btn.style.pointerEvents = 'none';
            });
            
            // Handle the answer (reuse existing logic)
            handleReverseAnswer(selectedChoice, button);
        }

        function showMobileDistance(distance, accuracy) {
            if (window.innerWidth > 768) return;
            
            const overlay = document.getElementById('mobile-distance-overlay');
            const distanceEl = document.getElementById('mobile-distance');
            const accuracyEl = document.getElementById('mobile-accuracy');
            
            if (overlay && distanceEl && accuracyEl) {
                distanceEl.textContent = distance;
                accuracyEl.textContent = accuracy;
                overlay.classList.remove('hidden');
            }
        }

        function hideMobileDistance() {
            if (window.innerWidth > 768) return;

            const overlay = document.getElementById('mobile-distance-overlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
        }

        function playBlastSound() {
            try {
                // Web Audio APIで爆発音を生成
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const frequencies = [100, 150, 200, 300];
                const duration = 0.3;

                frequencies.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(freq * 0.5, audioContext.currentTime + duration);
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3 / frequencies.length, audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    oscillator.start(audioContext.currentTime + index * 0.02);
                    oscillator.stop(audioContext.currentTime + duration + index * 0.02);
                });

                const bufferSize = audioContext.sampleRate * 0.1;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
                }

                const noiseSource = audioContext.createBufferSource();
                const noiseGain = audioContext.createGain();
                noiseSource.buffer = buffer;
                noiseSource.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                noiseGain.gain.setValueAtTime(0.2, audioContext.currentTime);
                noiseSource.start(audioContext.currentTime);
            } catch (e) {
                console.warn('Audio playback failed', e);
                try {
                    const boom = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGUdAy2A0PLWdiYEJmvA8NyQQAoUXrTp66hVFApGn+DyvGUdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYEJmvA8N2QQAoTXrPp66hWFAlFnt/yumQdAy2A0PLWdiYE');
                    boom.volume = 0.3;
                    boom.play();
                } catch (e2) {
                    console.warn('Fallback audio also failed');
                }
            }
        }

        function launchFireworksAtPoint(latlng, intensity = 'normal') {
            try {
                if (!gameState.map || !latlng) {
                    console.warn('Map or latlng not available for fireworks');
                    return;
                }
                const mapEl = document.getElementById('map');
                if (!mapEl) {
                    console.warn('Map element not found');
                    return;
                }
                const point = gameState.map.latLngToContainerPoint(latlng);

                const intensitySettings = {
                    'small': {
                        particles: 30,
                        explosion: 3,
                        intensity: 10,
                        containerSize: 200,
                        duration: 1500,
                        cssParticles: 8
                    },
                    'normal': {
                        particles: 50,
                        explosion: 5,
                        intensity: 20,
                        containerSize: 300,
                        duration: 2500,
                        cssParticles: 12
                    },
                    'good': {
                        particles: 70,
                        explosion: 7,
                        intensity: 30,
                        containerSize: 350,
                        duration: 3000,
                        cssParticles: 16
                    },
                    'spectacular': {
                        particles: 100,
                        explosion: 10,
                        intensity: 60,
                        containerSize: 400,
                        duration: 3500,
                        cssParticles: 20
                    },
                    'bonus': {
                        particles: 80,
                        explosion: 8,
                        intensity: 50,
                        containerSize: 350,
                        duration: 2000,
                        cssParticles: 15
                    }
                };

                const settings = intensitySettings[intensity] || intensitySettings['normal'];

                let FireworksClass = null;
                if (typeof Fireworks === 'function') {
                    FireworksClass = Fireworks;
                } else if (typeof Fireworks === 'object' && typeof Fireworks.Fireworks === 'function') {
                    FireworksClass = Fireworks.Fireworks;
                }

                if (FireworksClass) {
                    const containerSize = settings.containerSize;
                    const fireworksContainer = document.createElement('div');
                    fireworksContainer.style.position = 'absolute';
                    fireworksContainer.style.pointerEvents = 'none';
                    fireworksContainer.style.left = (point.x - containerSize/2) + 'px';
                    fireworksContainer.style.top = (point.y - containerSize/2) + 'px';
                    fireworksContainer.style.width = containerSize + 'px';
                    fireworksContainer.style.height = containerSize + 'px';
                    fireworksContainer.style.zIndex = '2000';
                    mapEl.appendChild(fireworksContainer);

                    const fireworks = new FireworksClass(fireworksContainer, {
                        autoresize: false,
                        opacity: intensity === 'spectacular' ? 0.8 : 0.6,
                        acceleration: 1.05,
                        friction: 0.97,
                        gravity: intensity === 'small' ? 2.0 : 1.5,
                        particles: settings.particles,
                        traceLength: intensity === 'spectacular' ? 4 : 3,
                        explosion: settings.explosion,
                        intensity: settings.intensity,
                        flickering: intensity === 'spectacular' ? 70 : 50,
                        lineStyle: 'round',
                        hue: intensity === 'spectacular' ? { min: 0, max: 360 } : intensity === 'bonus' ? { min: 340, max: 60 } : { min: 0, max: 360 },
                        delay: { min: 30, max: 60 },
                        rocketsPoint: { min: containerSize / 2, max: containerSize / 2 },
                        lineWidth: {
                            explosion: { min: intensity === 'small' ? 1 : 2, max: intensity === 'spectacular' ? 4 : 3 },
                            trace: { min: 1, max: intensity === 'spectacular' ? 5 : 2 }
                        },
                        brightness: { min: 50, max: intensity === 'spectacular' ? 90 : 80 },
                        decay: { min: 0.015, max: intensity === 'small' ? 0.05 : 0.03 }
                    });

                    fireworks.start();
                    setTimeout(() => {
                        try {
                            fireworks.stop();
                            if (fireworksContainer.parentNode) {
                                fireworksContainer.parentNode.removeChild(fireworksContainer);
                            }
                        } catch (e) {
                            console.warn('Fireworks cleanup failed', e);
                        }
                    }, settings.duration);

                } else {
                    console.log('Fireworks library not available, using CSS fallback');
                    createCSSFireworks(point, mapEl, settings);
                }
            } catch (e) {
                console.warn('Fireworks effect failed', e);
                createSimplePulseEffect(latlng, intensity);
            }
        }

        // CSS アニメーションによるフォールバック花火
        function createCSSFireworks(point, mapEl, settings) {
            const colors = ['#FFD700', '#FF6B35', '#F7931E', '#FFE135', '#C4D600', '#37BC9B'];
            const particleCount = settings.cssParticles;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.borderRadius = '50%';
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.left = point.x + 'px';
                particle.style.top = point.y + 'px';
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '2000';

                if (settings.particles > 70) {
                    particle.style.width = '6px';
                    particle.style.height = '6px';
                    particle.style.boxShadow = '0 0 6px currentColor';
                }

                const angle = (i / particleCount) * 2 * Math.PI + (Math.random() - 0.5) * 0.5;
                const distance = 30 + Math.random() * (settings.containerSize / 4);
                const endX = point.x + Math.cos(angle) * distance;
                const endY = point.y + Math.sin(angle) * distance;

                const animationDuration = settings.duration / 2;
                particle.style.transition = `all ${animationDuration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
                particle.style.opacity = '1';

                mapEl.appendChild(particle);

                setTimeout(() => {
                    particle.style.transform = `translate(${endX - point.x}px, ${endY - point.y}px)`;
                    particle.style.opacity = '0';
                }, 50);

                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, animationDuration + 100);
            }
        }

        // 最終フォールバック：シンプルなパルスエフェクト
        function createSimplePulseEffect(latlng, intensity = 'normal') {
            const intensityColors = {
                'small': '#2196F3',
                'normal': '#4CAF50',
                'good': '#FF9800',
                'spectacular': '#FFD700',
                'bonus': '#FF6B35'
            };

            const color = intensityColors[intensity] || '#4CAF50';
            const maxScale = intensity === 'spectacular' ? 6 : intensity === 'small' ? 3 : 4;

            const pulseMarker = L.circleMarker([latlng.lat, latlng.lng], {
                radius: 10,
                color: color,
                fillColor: color,
                fillOpacity: 0.6,
                weight: 3
            }).addTo(gameState.facilityLayer);

            let scale = 1;
            const pulseInterval = setInterval(() => {
                scale += 0.3;
                pulseMarker.setStyle({
                    radius: 10 * scale,
                    fillOpacity: 0.6 / scale,
                    opacity: 1 / scale
                });

                if (scale > maxScale) {
                    clearInterval(pulseInterval);
                    gameState.facilityLayer.removeLayer(pulseMarker);
                }
            }, 100);
        }

        function showResultModal(distance, accuracy) {
            const modal = document.getElementById("result-modal");
            const scoreSpan = document.querySelector("#score-text span");
            const distSpan = document.querySelector("#dist-text span");
            const circle = document.querySelector("#score-circle circle");
            const container = document.getElementById("score-circle");
            if (!modal || !scoreSpan || !distSpan || !circle || !container) return;
            const percent = Math.round(accuracy);
            scoreSpan.textContent = percent;
            distSpan.textContent = Math.round(distance);
            container.classList.remove("green","orange","red");
            if (distance <= 20) {
                container.classList.add("green");
            } else if (distance <= 100) {
                container.classList.add("orange");
            } else {
                container.classList.add("red");
            }
            const radius = circle.r.baseVal.value;
            const circumference = 2 * Math.PI * radius;
            circle.style.strokeDasharray = circumference;
            circle.style.strokeDashoffset = circumference;
            setTimeout(() => {
                circle.style.strokeDashoffset = circumference * (1 - percent / 100);
            }, 50);
            modal.classList.remove("hidden");
            let intensity = null;
            if (distance <= 25) {
                intensity = 'spectacular';
            } else if (distance <= 50) {
                intensity = gameState.timer >= 15 ? 'good' : 'normal';
            } else if (distance <= 100) {
                intensity = 'small';
            }

            if (intensity) {
                if (gameState.lastGuess) {
                    launchFireworksAtPoint(gameState.lastGuess, intensity);
                }
                playBlastSound();
            }
            const nextBtn = document.getElementById("next-question");
            if (nextBtn) nextBtn.classList.add("hidden");
        }

        function closeModal() {
            const modal = document.getElementById("result-modal");
            const circle = document.querySelector("#score-circle circle");
            if (modal && circle) {
                const radius = circle.r.baseVal.value;
                const circumference = 2 * Math.PI * radius;
                circle.style.strokeDashoffset = circumference;
                modal.classList.add("hidden");
            }
            nextQuestion();
        }

        // Game state
        let gameState = {
            isPlaying: false,
            currentMode: 'street',
            difficulty: 'tourist',
            score: 0,
            streak: 0,
            totalQuestions: 0,
            currentQuestion: null,
            timer: 30,
            timerInterval: null,
            timerExpired: false,
            map: null,
            gameArea: null,
            userMarker: null,
            correctMarker: null,
            streetLayer: null,
            facilityLayer: null,
            highlightLayer: null,
            lastGuess: null,
            center: { lat: 35.6762, lng: 139.6503 },
            range: 5,
            savedRange: 5,
            showLabels: true,
            baseLayers: {},
            streetData: null,
            isLoadingData: false,
            isMapInitialized: false,
            settingsVisible: true,
            customProblems: [],
            customIndex: 0,
            customProblemsOnly: false,
            skipMissingKml: true,
            editorMode: false,
            currentEditPoints: [],
            editingProblem: null,
            askedQuestions: [],
            currentLocation: null,
            geotextbookFacilities: [],
            // NEW: curated intersections (地理教本交差点)
            geotextbookIntersections: [],
            geotextbookArea: 'tokyo23',
            playOrder: loadSetting('geotextbook_playOrder', 'random'),
            registrationList: [],
            registrationIndex: 0,
            totalRetryCount: 0,
            retryCountPerQuestion: [],
            registrationRetryLimit: loadSetting('geotextbook_retry_limit', null),
            registrationNextDelayMs: loadSetting('geotextbook_next_delay_ms', 0),
            
            backgroundLoading: false,
            cacheEnabled: true,
            dataQuality: 'partial',
            initRetryCount: 0,            
            isMobileDevice: false,
            networkStatus: 'unknown',
            // New fields for problem source management
            problemSource: 'mixed', // 'osm-only', 'custom-only', 'mixed'
            osmCustomRatio: 0.7, // Default 70% OSM, 30% custom
            customDifficultyMode: 'auto', // 'auto' or 'manual'
            initialLocationPrompted: false,
            speedRun: {
                active: false,
                startTime: null,
                endTime: null,
                correctCount: 0,
                targetCount: loadSetting('geotextbook_speedrun_targetCount', 5),
                toleranceMultiplier: loadSetting('geotextbook_speedrun_toleranceMultiplier', 2.0),
                baseToleranceKm: 1.5,
                timerInterval: null,
                bestTime: loadSetting('geotextbook_speedrun_bestTime', null)
            }
       };

        // Example facility data with coordinates
        const facilityQuestions = [
            {
                name: "東京タワー",
                points: [[{ lat: 35.6586, lng: 139.7454 }]],
                isEnclosedArea: false,
                facilityType: "tower",
                category: "tourism",
                importance: 80,
                description: "333mの赤い電波塔",
                source: "default"
            },
            {
                name: "東京駅",
                points: [[{ lat: 35.6812, lng: 139.7671 }]],
                isEnclosedArea: false,
                facilityType: "station",
                category: "transport",
                importance: 90,
                description: "東京の玄関口となる中央駅",
                source: "default"
            },
            {
                name: "東京ドームシティ",
                points: [[
                    { "lat": 35.7060, "lng": 139.7555 },
                    { "lat": 35.7060, "lng": 139.7490 },
                    { "lat": 35.7045, "lng": 139.7490 },
                    { "lat": 35.7045, "lng": 139.7555 },
                    { "lat": 35.7060, "lng": 139.7555 }
                ]],
                isEnclosedArea: true,
                facilityType: "stadium",
                category: "entertainment",
                importance: 75,
                description: "野球場とアミューズメント施設が集まるエリア",
                source: "default"
            },
            {
                name: "東京スカイツリー",
                points: [[{ lat: 35.71008992378027, lng: 139.81066150759884 }]],
                isEnclosedArea: false,
                facilityType: "tower",
                category: "tourism",
                importance: 95,
                description: "634mの世界一高い自立式電波塔",
                source: "default"
            },
            {
                name: "浅草寺",
                points: [[{ lat: 35.7148, lng: 139.7967 }]],
                isEnclosedArea: true,
                facilityType: "temple",
                category: "culture",
                importance: 95,
                description: "東京最古の寺院で、雷門が有名",
                source: "default"
            }
        ];

        const intersectionQuestions = [
            {
                name: "渋谷スクランブル交差点",
                points: [[{ lat: 35.6598, lng: 139.7006 }]],
                importance: 90,
                description: "世界で最も混雑する歩行者用交差点",
                source: "default"
            },
            {
                name: "銀座四丁目交差点",
                points: [[{ lat: 35.6717, lng: 139.7635 }]],
                importance: 80,
                description: "銀座の中心となる大きな交差点",
                source: "default"
            },
            {
                name: "新橋駅前交差点",
                points: [[{ lat: 35.6660, lng: 139.7671 }]],
                importance: 75,
                description: "新橋駅の正面に位置する交差点",
                source: "default"
            },
            {
                name: "六本木ヒルズ前交差点",
                points: [[{ lat: 35.6586, lng: 139.7292 }]],
                importance: 85,
                description: "六本木ヒルズの入口にある交差点",
                source: "default"
            },
            {
                name: "秋葉原電気街口交差点",
                points: [[{ lat: 35.6984, lng: 139.7730 }]],
                importance: 70,
                description: "秋葉原の主要な電気街入口の交差点",
                source: "default"
            },
            {
                name: "上野公園前交差点",
                points: [[{ lat: 35.7123, lng: 139.7768 }]],
                importance: 75,
                description: "上野公園の入口に位置する交差点",
                source: "default"
            },
            {
                name: "池袋西口交差点",
                points: [[{ lat: 35.7295, lng: 139.7100 }]],
                importance: 85,
                description: "池袋駅西口の主要な交差点",
                source: "default"
            },
            {
                name: "新宿東口交差点",
                points: [[{ lat: 35.6896, lng: 139.7006 }]],
                importance: 75,
                description: "新宿駅東口前の主要交差点",
                source: "default"
            }
        ];

        const GEOTEXTBOOK_AREA_CONFIGS = {
            'tokyo23': {
                name: '東京23区武三',
                file: 'custom-facilities/東京23区武三.json',
                // NEW: intersections file alongside facilities
                intersectionsFile: 'custom-intersections/東京23区武三.json',
                center: { lat: 35.6895, lng: 139.6917 },
                bbox: '35.5,139.4,35.9,139.9'
            }
        };

        // NEW: loader for curated intersections
        async function loadGeotextbookIntersections(areaKey) {
            try {
                const cfg = GEOTEXTBOOK_AREA_CONFIGS[areaKey] || GEOTEXTBOOK_AREA_CONFIGS['tokyo23'];
                if (!cfg?.intersectionsFile) {
                    gameState.geotextbookIntersections = [];
                    return;
                }
                const res = await fetch(cfg.intersectionsFile);
                const data = await res.json();
                // 正規化: 施設と同じスキーマに寄せる
                gameState.geotextbookIntersections = (data || []).map(it => ({
                    name: it.name,
                    type: 'intersection',
                    description: it.description || '地理教本交差点',
                    importance: it.importance ?? 70,
                    points: it.points,
                    isEnclosedArea: false,
                    source: 'preset'
                }));
            } catch (e) {
                console.warn('loadGeotextbookIntersections failed:', e);
                gameState.geotextbookIntersections = [];
            }
        }

        // Regional bbox configurations for full road network extraction
        const REGIONAL_CONFIGS = {
            'south-kanto': {
                name: '南関東',
                bbox: { south: 34.8, west: 138.8, north: 36.3, east: 140.9 },
                majorRoads: [
                    '環状七号線', '環状八号線', '甲州街道', '青梅街道', '目白通り', '明治通り',
                    '昭和通り', '中央通り', '外苑東通り', '外苑西通り', '靖国通り', '新宿通り',
                    '表参道', '竹下通り', '六本木通り', '麻布通り', '桜田通り', '第一京浜',
                    '第二京浜', '産業道路', '多摩川通り', '世田谷通り', '駒沢通り', '玉川通り',
                    '国道1号', '国道14号', '国道15号', '国道16号', '国道20号', '国道246号',
                    '国道357号', '国道409号', '都道418号', '山手通り', '井の頭通り',
                    '五日市街道', '小金井街道', '中野通り', '早稲田通り', '春日通り',
                    '不忍通り', '言問通り', '水戸街道', '蔵前橋通り', '清洲橋通り'
                ]
            },
            'tokyo-center': {
                name: '東京都心',
                bbox: { south: 35.6, west: 139.6, north: 35.75, east: 139.85 },
                majorRoads: [
                    '環状七号線', '環状八号線', '山手通り', '明治通り', '昭和通り',
                    '中央通り', '外苑東通り', '靖国通り', '新宿通り', '表参道',
                    '六本木通り', '桜田通り', '第一京浜', '国道1号', '国道14号',
                    '国道15号', '国道20号', '国道246号'
                ]
            }
        };

        // Optimized loading strategy
        const LOADING_STRATEGIES = {
            'immediate': {
                name: '即座開始 (Fast Start)',
                description: '基本的な道路のみ事前読み込み、他は必要時に取得',
                preloadCount: 10,
                batchSize: 3,
                delay: 1000
            },
            'balanced': {
                name: 'バランス型 (Balanced)',
                description: '重要な道路を段階的に読み込み',
                preloadCount: 20,
                batchSize: 4,
                delay: 1500
            },
            'complete': {
                name: '完全読み込み (Complete)',
                description: '全道路を事前読み込み（時間がかかります）',
                preloadCount: -1,
                batchSize: 5,
                delay: 2000
            }
        };

        // Cache system for loaded road data
        const ROAD_CACHE = {
            data: new Map(),

            save: function(regionKey, strategyKey, roadData) {
                const cacheKey = `${regionKey}-${strategyKey}`;
                this.data.set(cacheKey, {
                    roads: roadData,
                    timestamp: Date.now(),
                    version: '1.0'
                });

                // localStorageへの保存を廃止
                // try {
                //     const compressed = JSON.stringify({
                //         roads: roadData,
                //         timestamp: Date.now()
                //     });
                //     localStorage.setItem(`roadCache_${cacheKey}`, compressed);
                // } catch (error) {
                //     console.warn('Could not save to localStorage:', error);
                // }
            },

            load: function(regionKey, strategyKey) {
                return null; // キャッシュからの読み込みは使わない
            },

            exists: function(regionKey, strategyKey) {
                return this.load(regionKey, strategyKey) !== null;
            }
        };

        function saveSetting(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.warn("保存に失敗:", key, e);
            }
        }

        function loadSetting(key, defaultValue = null) {
            try {
                const val = localStorage.getItem(key);
                return val ? JSON.parse(val) : defaultValue;
            } catch (e) {
                return defaultValue;
            }
        }

        const ROAD_TYPE_SCORES = {
            motorway: 90,
            trunk: 85,
            primary: 80,
            secondary: 75,
            tertiary: 70,
            residential: 55,
            unclassified: 50,
            service: 45
        };

        const DIFFICULTY_ALLOWED_TYPES = {
            'tourist': ['motorway', 'trunk', 'primary'],
            'resident': ['motorway', 'trunk', 'primary', 'secondary', 'tertiary'],
            'taxi-driver': ['motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'residential', 'unclassified', 'service']
        };

        // Current regional configuration and loading strategy
        let currentRegionalConfig = REGIONAL_CONFIGS['south-kanto'];
        let currentLoadingStrategy = LOADING_STRATEGIES['immediate'];

        // Initialize the game
        async function initGame() {
            try {
                log('Initializing game...');

                // Check if required libraries are loaded
                const libCheck = checkLibraryLoading();
                if (!libCheck.leaflet) {
                    log('Leaflet not loaded yet, retrying...');
                    setTimeout(initGame, 1000);
                    return;
                }

                window.kmlMap = await fetchKmlIndex();

                gameState.difficulty = loadSetting('boh_difficulty', 'tourist');
                gameState.currentMode = loadSetting('boh_mode', 'street');
                if (gameState.currentMode === 'street') {
                    gameState.currentMode = 'facility';
                    saveSetting('boh_mode', gameState.currentMode);
                }
                gameState.range = loadSetting('boh_rangeKm', 5);
                gameState.savedRange = gameState.range;
                const savedLoc = loadSetting('boh_lastLocation', null);
                if (savedLoc && savedLoc.lat && savedLoc.lng) {
                    gameState.center = savedLoc;
                }

                // Initialize components in correct order
                initMap();
                bindEvents();
                const diffEl = document.getElementById('difficulty');
                if (diffEl) diffEl.value = gameState.difficulty;
                const modeTab = document.querySelector(`.mode-tab[data-mode="${gameState.currentMode}"]`);
                if (modeTab) modeTab.classList.add('active');
                const modeSelect = document.getElementById('game-mode-select');
                if (modeSelect) modeSelect.value = gameState.currentMode;
                const areaSelectInit = document.getElementById('geotextbook-area-select');
                if (areaSelectInit) {
                    areaSelectInit.value = gameState.geotextbookArea;
                    areaSelectInit.style.display = (gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') ? 'block' : 'none';
                }
                const orderSelectInit = document.getElementById('geotextbook-play-order');
                if (orderSelectInit) {
                    orderSelectInit.value = gameState.playOrder;
                    orderSelectInit.style.display = (gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') ? 'block' : 'none';
                }

                const rangeEl = document.getElementById('range');
                if (gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') {
                    gameState.range = Infinity;
                    if (rangeEl) {
                        rangeEl.disabled = true;
                        rangeEl.style.display = 'none';
                    }
                } else {
                    if (rangeEl) {
                        rangeEl.disabled = false;
                        rangeEl.style.display = 'block';
                        rangeEl.value = gameState.range;
                    }
                }
                updateRangeDisplay();
                loadCustomProblems();
                await loadGeotextbookFacilities(gameState.geotextbookArea);
                await loadGeotextbookIntersections(gameState.geotextbookArea);
                updateRangeDisplay();
                updateImportanceDisplay();
                updateAutoDifficultyDisplay();
                updateDataStatus();

                promptInitialLocation();

                log('Game initialization complete');
                // Start loading Street data in background
                prepareStreetMode();
            } catch (error) {
                log('Error initializing game: ' + error.message);
                console.error('Game initialization error:', error);
                
                // Retry initialization
                if (gameState.initRetryCount < 1) {
                    gameState.initRetryCount++;
                    setTimeout(() => {
                        log(`Retrying game initialization... (attempt ${gameState.initRetryCount}/1)`);
                        initGame();
                    }, 2000);
                } else {
                    log('Max retry attempts reached. Please refresh the page.');
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        debugInfo.innerHTML = 'Game initialization failed. <button onclick="location.reload()" style="background:#f44336;color:white;border:none;padding:0.5rem;border-radius:4px;margin-left:0.5rem;">Refresh Page</button>';
                        debugInfo.style.display = 'block';
                        debugInfo.style.background = '#f44336';
                    }
                }
            }
        }

        function initMap() {
            try {
                log('Creating map...');
                
                const libCheck = checkLibraryLoading();
                if (!libCheck.leaflet) {
                    log('Leaflet not loaded yet, retrying...');
                    setTimeout(initMap, 1000);
                    return;
                }
                
                const mapContainer = document.getElementById('map');
                if (!mapContainer) {
                    log('Map container not found, retrying...');
                    setTimeout(initMap, 100);
                    return;
                }

                showLoading();
                
                if (mapContainer._leaflet_id) {
                    log('Removing existing map...');
                    if (gameState.map) {
                        gameState.map.remove();
                        gameState.map = null;
                    }
                }
                
                if (window.innerWidth <= 768) {
                    initializeForMobile();
                }
                
                log('Initializing new map...');
                gameState.map = L.map('map', {
                    zoomControl: false,
                    center: [gameState.center.lat, gameState.center.lng],
                    zoom: 12,
                    tap: true,
                    tapTolerance: 15,
                    touchZoom: true,
                    bounceAtZoomLimits: true,
                    preferCanvas: true,
                    maxZoom: 18,
                    minZoom: 6,
                    zoomSnap: 1,
                    zoomDelta: 1,
                    wheelPxPerZoomLevel: 60,
                    maxBounds: [[20, 120], [50, 155]], // 日本周辺に制限
                    maxBoundsViscosity: 0.7
                });
                
                log('Map object created, setting up tile layers...');
                
                // 透明タイル（エラー時用）
                const transparentTile = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                
                // 共通のタイルオプション
                const commonTileOpts = {
                    subdomains: ['a', 'b', 'c'],
                    maxZoom: 18,
                    minZoom: 3,
                    tileSize: 256,
                    errorTileUrl: transparentTile,
                    crossOrigin: true,
                    detectRetina: false
                };
                
                // 複数のタイルサーバーを設定（フォールバック用）
                const tileServers = {
                    osm: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    osmFallback: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                    cartoLight: 'https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}.png',
                    cartoLightFallback: 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}.png'
                };
                
                // ラベルあり（OSM 標準）
                const layerWithLabels = L.tileLayer(tileServers.osm, {
                    ...commonTileOpts,
                    attribution: '© OpenStreetMap contributors'
                });
                
                // ラベルなし（CartoDB Light No Labels）
                const layerWithoutLabels = L.tileLayer(tileServers.cartoLight, {
                    ...commonTileOpts,
                    attribution: '© OpenStreetMap contributors, © CARTO'
                });
                
                // フォールバック機能
                let retryCount = 0;
                const maxRetries = 1;
                
                const createFallbackLayer = function(isLabeled) {
                    retryCount++;
                    log(`Creating fallback layer ${retryCount}/${maxRetries} for ${isLabeled ? 'labeled' : 'unlabeled'} tiles`);
                    
                    if (retryCount >= maxRetries) {
                        log('Max retries reached for tile server');
                        return null;
                    }
                    
                    const fallbackUrl = isLabeled ? tileServers.osmFallback : tileServers.cartoLightFallback;
                    return L.tileLayer(fallbackUrl, {
                        ...commonTileOpts,
                        attribution: '© OpenStreetMap contributors' + (isLabeled ? '' : ', © CARTO')
                    });
                };
                
                // エラータイル処理を強化
                const handleTileError = function(e) {
                    if (e.tile) {
                        e.tile.style.display = 'none';
                        e.tile.style.visibility = 'hidden';
                        e.tile.style.opacity = '0';
                        
                        // 透明画像に置き換え
                        setTimeout(() => {
                            if (e.tile.parentNode) {
                                e.tile.src = transparentTile;
                            }
                        }, 100);
                    }
                };
                
                // タイル読み込み成功時の処理
                const handleTileLoad = function(e) {
                    if (e.tile) {
                        e.tile.style.opacity = '1';
                        e.tile.style.visibility = 'visible';
                    }
                };
                
                [layerWithLabels, layerWithoutLabels].forEach(layer => {
                    layer.on('tileloadstart', function(e) {
                        showLoading();
                        if (e.tile) {
                            e.tile.style.opacity = '0.5';
                        }
                    });

                    layer.on('tileload', function(e) {
                        handleTileLoad(e);
                        hideLoading();
                    });

                    layer.on('tileerror', function(e) {
                        handleTileError(e);
                        hideLoading();
                    });
                });
                
                // 初期表示はラベルあり
                layerWithLabels.addTo(gameState.map);
                gameState.showLabels = true;
                gameState.map.on('load', hideLoading);
                
                // baseLayers を gameState に保存
                gameState.baseLayers = {
                    withLabels: layerWithLabels,
                    withoutLabels: layerWithoutLabels
                };
                
                // タイルサーバーの健全性チェック
                function checkTileServerHealth() {
                    const testUrls = [
                        'https://a.tile.openstreetmap.org/10/512/341.png',
                        'https://a.basemaps.cartocdn.com/light_nolabels/10/512/341.png'
                    ];
                    
                    let healthyServers = 0;
                    let totalServers = testUrls.length;
                    
                    testUrls.forEach((url, index) => {
                        const img = new Image();
                        img.onload = function() {
                            healthyServers++;
                            log(`Tile server ${index + 1} is healthy`);
                            
                            if (healthyServers === totalServers) {
                                log('All tile servers are healthy');
                            }
                        };
                        img.onerror = function() {
                            log(`Warning: Tile server ${index + 1} connectivity issues detected`);
                            
                            if (healthyServers === 0 && index === totalServers - 1) {
                                showWarning('地図タイルの読み込みに問題があります。ネットワーク接続を確認してください。');
                            }
                        };
                        img.src = url;
                    });
                }
                
                // 地図読み込み完了後にタイルサーバーをチェック (disabled for faster startup)
                // setTimeout(checkTileServerHealth, 2000);
                
                // レイヤーコントロールを追加
                const baseMaps = {
                    'Labels On': layerWithLabels,
                    'Labels Off': layerWithoutLabels
                };
                
                // レイヤー切り替えイベントを監視
                gameState.map.on('baselayerchange', function(e) {
                    gameState.showLabels = (e.name === 'Labels On');
                    updateToggleButton();
                    log(`Layer changed to: ${e.name} (showLabels: ${gameState.showLabels})`);
                });
                
                gameState.streetLayer = L.layerGroup().addTo(gameState.map);
                gameState.facilityLayer = L.layerGroup().addTo(gameState.map);

                updateGameArea();
                
                // 安全に updateToggleButton を呼び出す
                updateToggleButton();
                
                gameState.isMapInitialized = true;
                log('Map initialized successfully with layer control');
                
                // Update debug info to show success
                const debugInfo = document.getElementById('debug-info');
                if (debugInfo) {
                    debugInfo.innerHTML = '✅ Map ready for interaction';
                    debugInfo.style.background = '#4CAF50';
                    debugInfo.style.color = 'white';
                    setTimeout(() => {
                        debugInfo.style.display = 'none';
                    }, 2000);
                }
                
                gameState.map.on('click', function(e) {
                    log('Map click detected at: ' + e.latlng.lat.toFixed(4) + ', ' + e.latlng.lng.toFixed(4));
                    handleMapClick(e);
                });
                
                gameState.map.whenReady(function() {
                    log('Map is ready for interaction');
                    hideLoading();
                    setTimeout(() => {
                        gameState.map.invalidateSize();
                        log('Map size invalidated and ready');
                    }, 500);
                });
                
                gameState.map.on('moveend', function() {
                    log('Map moved to: ' + gameState.map.getCenter().lat.toFixed(4) + ', ' + gameState.map.getCenter().lng.toFixed(4));
                });
                
                if (window.innerWidth <= 768) {
                    gameState.map.on('zoomstart', function() {
                        log('Mobile zoom started');
                    });
                    
                    gameState.map.on('zoomend', function() {
                        log('Mobile zoom ended at level: ' + gameState.map.getZoom());
                    });
                }
                
            } catch (error) {
                log('Error creating map: ' + error.message);
                console.error('Map initialization error:', error);

                hideLoading();
                
                // 無限ループを防ぐため、リトライ回数を制限
                if (gameState.initRetryCount < 1) {
                    gameState.initRetryCount++;
                    setTimeout(() => {
                        log(`Retrying map initialization... (attempt ${gameState.initRetryCount}/1)`);
                        initMap();
                    }, 3000);
                } else {
                    log('Max retry attempts reached. Please refresh the page.');
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        debugInfo.innerHTML = 'Map initialization failed. <button onclick="location.reload()" style="background:#f44336;color:white;border:none;padding:0.5rem;border-radius:4px;margin-left:0.5rem;">Refresh Page</button>';
                        debugInfo.style.display = 'block';
                        debugInfo.style.background = '#f44336';
                    }
                }
            }
        }

        function updateToggleButton() {
            try {
                const toggleBtn = document.getElementById('toggle-labels');
                if (toggleBtn) {
                    const baseText = gameState.showLabels ? '街路名非表示' : '街路名表示';
                    toggleBtn.textContent = baseText;
                    
                    // ゲーム中は次の問題で自動的に非表示に戻ることを示す
                    if (gameState.isPlaying && gameState.showLabels) {
                        toggleBtn.title = '街路名表示中（次の問題で自動的に非表示に戻ります）';
                    } else if (gameState.isPlaying && !gameState.showLabels) {
                        toggleBtn.title = '街路名非表示中（手動で表示可能ですが、次の問題で自動的に非表示に戻ります）';
                    } else {
                        toggleBtn.title = '街路名表示切替';
                    }
                    
                    log('Toggle button updated: ' + (gameState.showLabels ? 'Labels ON' : 'Labels OFF') + (gameState.isPlaying ? ' (Game Active)' : ''));
                }
            } catch (error) {
                log('Error updating toggle button: ' + error.message);
            }
        }

        function updateGameArea() {
            try {
                if (gameState.gameArea) {
                    gameState.map.removeLayer(gameState.gameArea);
                    gameState.gameArea = null;
                }

                if (!gameState.center || !gameState.map || !isFinite(gameState.range)
                    || gameState.currentMode === 'geotextbook'
                    || gameState.currentMode === 'geotextbook-intersection') {
                    return;
                }

                gameState.gameArea = L.circle([gameState.center.lat, gameState.center.lng], {
                    radius: gameState.range * 1000,
                    fillColor: '#4CAF50',
                    fillOpacity: 0.1,
                    color: '#4CAF50',
                    weight: 2
                }).addTo(gameState.map);

                log('Game area updated');
            } catch (error) {
                log('Error updating game area: ' + error.message);
            }
        }

       async function handleModeChange(mode) {
            gameState.currentMode = mode;
            saveSetting('boh_mode', gameState.currentMode);
            log('Mode changed to: ' + gameState.currentMode);

            const rangeEl = document.getElementById('range');
            if (mode === 'geotextbook' || mode === 'geotextbook-intersection') {
                if (isFinite(gameState.range)) gameState.savedRange = gameState.range;
                gameState.range = Infinity;
                if (rangeEl) {
                    rangeEl.disabled = true;
                    rangeEl.style.display = 'none';
                }
            } else {
                if (rangeEl) {
                    rangeEl.disabled = false;
                    rangeEl.style.display = 'block';
                }
                if (!isFinite(gameState.range)) {
                    gameState.range = gameState.savedRange || 5;
                    if (rangeEl) rangeEl.value = gameState.range;
                }
            }
            updateRangeDisplay();
            updateGameArea();

            if (mode === 'street') {
                await prepareStreetMode();
            } else if (mode === 'facility') {
                loadFacilityDataFromOverpass();
            } else if (mode === 'intersection') {
                loadIntersectionDataFromOverpass();
            } else if (mode === "geotextbook") {
                const areaSelect = document.getElementById("geotextbook-area-select");
                gameState.geotextbookArea = areaSelect ? areaSelect.value : gameState.geotextbookArea;
                await loadGeotextbookFacilities(gameState.geotextbookArea);
                const orderSelect = document.getElementById('geotextbook-play-order');
                const order = orderSelect ? orderSelect.value : 'random';
                gameState.playOrder = order;
                gameState.speedRun.active = (order === 'random');
            } else if (mode === "geotextbook-intersection") {
                const areaSelect = document.getElementById("geotextbook-area-select");
                gameState.geotextbookArea = areaSelect ? areaSelect.value : gameState.geotextbookArea;
                await loadGeotextbookIntersections(gameState.geotextbookArea);
                const orderSelect = document.getElementById('geotextbook-play-order');
                const order = orderSelect ? orderSelect.value : 'random';
                gameState.playOrder = order;
                gameState.speedRun.active = (order === 'random');
            } else if (mode === "reverse") {
                loadFacilityDataFromOverpass();
                loadIntersectionDataFromOverpass();
            }

            if (mode !== 'geotextbook' && mode !== 'geotextbook-intersection') {
                gameState.speedRun.active = false;
            }
        }

        function bindEvents() {
            try {
                log('Binding events...');
                
                const menuToggle = document.getElementById('menu-toggle');
                const sidebar = document.getElementById('sidebar');
                if (menuToggle && sidebar) {
                    menuToggle.addEventListener('click', () => {
                        if (window.innerWidth <= 768) {
                            sidebar.classList.toggle('open');
                        } else {
                            sidebar.classList.toggle('closed');
                        }
                    });
                }

                document.querySelectorAll('.mode-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        log('Mode tab clicked: ' + e.target.dataset.mode);
                        document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        handleModeChange(e.target.dataset.mode);
                    });
                });

                const rangeSlider = document.getElementById('range');
                if (rangeSlider) {
                    rangeSlider.addEventListener('input', (e) => {
                        gameState.range = parseInt(e.target.value);
                        saveSetting('boh_rangeKm', gameState.range);
                        updateRangeDisplay();
                        updateGameArea();
                    });
                }

                const importanceSlider = document.getElementById('problem-importance');
                if (importanceSlider) {
                    importanceSlider.addEventListener('input', (e) => {
                        updateImportanceDisplay();
                        updateAutoDifficultyDisplay();
                    });
                }

                const difficultySelect = document.getElementById('difficulty');
                if (difficultySelect) {
                    difficultySelect.addEventListener('change', (e) => {
                        gameState.difficulty = e.target.value;
                        saveSetting('boh_difficulty', gameState.difficulty);
                        log('Difficulty changed to: ' + gameState.difficulty);
                    });
                }

                const problemSourceSelect = document.getElementById('problem-source');
                if (problemSourceSelect) {
                    problemSourceSelect.addEventListener('change', (e) => {
                        gameState.problemSource = e.target.value;
                        const ratioControl = document.getElementById('source-ratio-control');
                        if (ratioControl) {
                            ratioControl.style.display = e.target.value === 'mixed' ? 'block' : 'none';
                        }
                        log('Problem source changed to: ' + gameState.problemSource);
                    });
                }

                const osmCustomRatioSlider = document.getElementById('osm-custom-ratio');
                if (osmCustomRatioSlider) {
                    osmCustomRatioSlider.addEventListener('input', (e) => {
                        gameState.osmCustomRatio = parseInt(e.target.value) / 100;
                        const display = document.getElementById('ratio-display');
                        if (display) {
                            const customRatio = 100 - parseInt(e.target.value);
                            display.textContent = `${e.target.value}:${customRatio}`;
                        }
                    });
                }

                const difficultyModeSelect = document.getElementById('problem-difficulty-mode');
                if (difficultyModeSelect) {
                    difficultyModeSelect.addEventListener('change', (e) => {
                        const manualSelect = document.getElementById('problem-difficulty');
                        const autoDisplay = document.getElementById('auto-difficulty-display');
                        
                        if (e.target.value === 'manual') {
                            if (manualSelect) manualSelect.style.display = 'block';
                            if (autoDisplay) autoDisplay.style.display = 'none';
                        } else {
                            if (manualSelect) manualSelect.style.display = 'none';
                            if (autoDisplay) autoDisplay.style.display = 'block';
                            updateAutoDifficultyDisplay();
                        }
                    });
                }

                const startBtn = document.getElementById('start-game');
                const speedTargetInput = document.getElementById('speedrun-target');
                if (speedTargetInput) speedTargetInput.value = gameState.speedRun.targetCount;
                const speedTolInput = document.getElementById('speedrun-tolerance');
                if (speedTolInput) speedTolInput.value = gameState.speedRun.toleranceMultiplier;
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        log('Start game clicked');
                        startGame();
                    });
                }

                const modeSelect = document.getElementById('game-mode-select');
                if (modeSelect) {
                    modeSelect.addEventListener('change', (e) => {
                        const areaSel = document.getElementById('geotextbook-area-select');
                        if (areaSel) {
                            areaSel.style.display = (e.target.value === 'geotextbook' || e.target.value === 'geotextbook-intersection') ? 'block' : 'none';
                        }
                        const orderSel = document.getElementById('geotextbook-play-order');
                        if (orderSel) {
                            orderSel.style.display = (e.target.value === 'geotextbook' || e.target.value === 'geotextbook-intersection') ? 'block' : 'none';
                        }
                        const tgt = document.getElementById('speedrun-target');
                        const tol = document.getElementById('speedrun-tolerance');
                        if (tgt) tgt.style.display = (e.target.value === 'geotextbook' || e.target.value === 'geotextbook-intersection') ? 'block' : 'none';
                        if (tol) tol.style.display = (e.target.value === 'geotextbook' || e.target.value === 'geotextbook-intersection') ? 'block' : 'none';
                        handleModeChange(e.target.value);
                    });
                }

                const updateLocationBtn = document.getElementById('update-location');
                if (updateLocationBtn) {
                    updateLocationBtn.addEventListener('click', () => {
                        log('Update location clicked');
                        updateLocation();
                    });
                }

                const getCurrentLocationBtn = document.getElementById('get-current-location');
                if (getCurrentLocationBtn) {
                    getCurrentLocationBtn.addEventListener('click', () => {
                        log('Get current location clicked');
                        getCurrentLocation();
                    });
                }

                const locationInput = document.getElementById('location');
                if (locationInput) {
                    locationInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            updateLocation();
                        }
                    });
                }

                const loadDataBtn = document.getElementById('load-street-data');
                if (loadDataBtn) {
                    loadDataBtn.addEventListener('click', () => {
                        log('Load regional roads clicked');
                        const regionSelect = document.getElementById('region-select');
                        const strategySelect = document.getElementById('loading-strategy');

                        const selectedRegion = regionSelect ? regionSelect.value : 'south-kanto';
                        const selectedStrategy = strategySelect ? strategySelect.value : 'immediate';

                        loadRegionalRoadsOptimized(selectedRegion, selectedStrategy);
                    });
                }

                const loadFacilityBtn = document.getElementById('load-facility-data');
                if (loadFacilityBtn) {
                    loadFacilityBtn.addEventListener('click', () => {
                        log('Load facility data clicked');
                        loadFacilityDataFromOverpass();
                    });
                }

                const loadIntersectionBtn = document.getElementById('load-intersection-data');
                if (loadIntersectionBtn) {
                    loadIntersectionBtn.addEventListener('click', () => {
                        log('Load intersection data clicked');
                        loadIntersectionDataFromOverpass();
                    });
                }

                const regionSelect = document.getElementById('region-select');
                if (regionSelect) {
                    regionSelect.addEventListener('change', (e) => {
                        const selectedRegion = e.target.value;
                        log('Region changed to: ' + selectedRegion);
                        currentRegionalConfig = REGIONAL_CONFIGS[selectedRegion];
                        
                        if (gameState.map && currentRegionalConfig) {
                            const bbox = currentRegionalConfig.bbox;
                            const centerLat = (bbox.north + bbox.south) / 2;
                            const centerLng = (bbox.east + bbox.west) / 2;
                            gameState.center = { lat: centerLat, lng: centerLng };
                            gameState.map.setView([centerLat, centerLng], 9);
                            updateGameArea();
                        }
                    });
                }

                const geoAreaSelect = document.getElementById('geotextbook-area-select');
                if (geoAreaSelect) {
                    geoAreaSelect.addEventListener('change', (e) => {
                        gameState.geotextbookArea = e.target.value;
                        if (gameState.currentMode === 'geotextbook') {
                            loadGeotextbookAreaFacilities(gameState.geotextbookArea);
                        } else if (gameState.currentMode === 'geotextbook-intersection') {
                            loadGeotextbookIntersections(gameState.geotextbookArea);
                        }
                    });
                }

                const strategySelect = document.getElementById('loading-strategy');
                if (strategySelect) {
                    strategySelect.addEventListener('change', (e) => {
                        const selectedStrategy = e.target.value;
                        currentLoadingStrategy = LOADING_STRATEGIES[selectedStrategy];
                        log('Loading strategy changed to: ' + currentLoadingStrategy.name);
                        
                        const description = strategySelect.nextElementSibling;
                        if (description) {
                            description.textContent = currentLoadingStrategy.description;
                        }
                    });
                }

                const toggleSettingsBtn = document.getElementById('toggle-settings');
                if (toggleSettingsBtn) {
                    toggleSettingsBtn.addEventListener('click', () => {
                        toggleSettings();
                    });
                }

                const nextBtn = document.getElementById('next-question');
                if (nextBtn) {
                    nextBtn.addEventListener('click', async () => {
                        log('Next question clicked');
                        if ((gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') && gameState.playOrder === 'registration') {
                            handleRegistrationNext();
                        } else {
                            await nextQuestion();
                        }
                    });
                }

                const mobileNext = document.getElementById('mobile-next');
                if (mobileNext) {
                    mobileNext.addEventListener('click', async () => {
                        if ((gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') && gameState.playOrder === 'registration') {
                            handleRegistrationNext();
                        } else {
                            await nextQuestion();
                        }
                    });
                }

                const showAnswerBtn = document.getElementById('show-answer');
                if (showAnswerBtn) {
                    showAnswerBtn.addEventListener('click', () => {
                        log('Show answer clicked');
                        showAnswer();
                    });
                }

                const endBtn = document.getElementById('end-game');
                if (endBtn) {
                    endBtn.addEventListener('click', () => {
                        log('End game clicked');
                        endGame();
                    });
                }

                const saveBtn = document.getElementById('save-problem');
                if (saveBtn) {
                    saveBtn.addEventListener('click', saveProblem);
                }

                const cancelBtn = document.getElementById('cancel-edit');
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        clearProblemEditor();
                        gameState.editingProblem = null;
                        showInfo('Edit cancelled');
                    });
                }

                const clearPointsBtn = document.getElementById('clear-points');
                if (clearPointsBtn) {
                    clearPointsBtn.addEventListener('click', clearPoints);
                }

                const kmlFileInput = document.getElementById('kml-file');
                if (kmlFileInput) {
                    kmlFileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            handleKmlFile(file);
                        }
                    });
                }

                const zoomInBtn = document.getElementById('zoom-in');
                if (zoomInBtn) {
                    zoomInBtn.addEventListener('click', () => {
                        if (gameState.map) {
                            gameState.map.zoomIn();
                        }
                    });
                }

                const zoomOutBtn = document.getElementById('zoom-out');
                if (zoomOutBtn) {
                    zoomOutBtn.addEventListener('click', () => {
                        if (gameState.map) {
                            gameState.map.zoomOut();
                        }
                    });
                }

                const toggleLabelsBtn = document.getElementById('toggle-labels');
                if (toggleLabelsBtn) {
                    toggleLabelsBtn.addEventListener('click', () => {
                        toggleLabels();
                    });
                }

                const gameBtnAnswer = document.getElementById('game-btn-answer');
                if (gameBtnAnswer) {
                    gameBtnAnswer.addEventListener('click', () => {
                        showAnswer();
                    });
                }

                const gameBtnNext = document.getElementById('game-btn-next');
                if (gameBtnNext) {
                    gameBtnNext.addEventListener('click', () => {
                        if ((gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') && gameState.playOrder === 'registration') {
                            handleRegistrationNext();
                        } else {
                            closeModal();
                        }
                    });
                }

                const gameBtnEnd = document.getElementById('game-btn-end');
                if (gameBtnEnd) {
                    gameBtnEnd.addEventListener('click', () => {
                        const modal = document.getElementById('result-modal');
                        if (modal) modal.classList.add('hidden');
                        endGame();
                    });
                }

                document.addEventListener('click', (e) => {
                    if (window.innerWidth <= 768) {
                        const sidebar = document.getElementById('sidebar');
                        const menuToggle = document.getElementById('menu-toggle');
                        
                        if (!sidebar.contains(e.target) && 
                            e.target !== menuToggle) {
                            sidebar.classList.remove('open');
                        }
                    }
                });

                log('Events bound successfully');
            } catch (error) {
                log('Error binding events: ' + error.message);
                console.error('Event binding error:', error);
            }
        }

        function toggleSettings() {
            gameState.settingsVisible = !gameState.settingsVisible;
            const toggleBtn = document.getElementById('toggle-settings');
            const advancedSettings = document.getElementById('advanced-settings');
            
            if (gameState.settingsVisible) {
                if (advancedSettings) advancedSettings.classList.add('hidden');
                toggleBtn.textContent = '🔧 Show Advanced Tools';
            } else {
                if (advancedSettings) advancedSettings.classList.remove('hidden');
                toggleBtn.textContent = '⚙️ Hide Advanced Tools';
            }
        }

        function toggleLabels() {
            try {
                log('Toggle labels clicked. Current state: ' + gameState.showLabels);
                gameState.showLabels = !gameState.showLabels;
                
                gameState.map.eachLayer(function(layer) {
                    if (layer instanceof L.TileLayer) {
                        gameState.map.removeLayer(layer);
                    }
                });
                
                if (gameState.showLabels) {
                    gameState.baseLayers.withLabels.addTo(gameState.map);
                    log('Switched to labels ON');
                } else {
                    gameState.baseLayers.withoutLabels.addTo(gameState.map);
                    log('Switched to labels OFF');
                }
                
                updateToggleButton();
                
                setTimeout(() => {
                    gameState.map.invalidateSize();
                }, 200);
                
                log('Labels toggled successfully to: ' + (gameState.showLabels ? 'shown' : 'hidden'));
            } catch (error) {
                log('Error toggling labels: ' + error.message);
                console.error('Toggle labels error:', error);
            }
        }

        function updateDataStatus() {
            const statusDiv = document.getElementById('data-status');
            if (statusDiv) {
                const customStreetCount = gameState.customProblems.filter(p => p.type === 'street').length;
                const customBreakdown = getCustomStreetBreakdownByDifficulty();
                
                if (gameState.streetData && gameState.streetData.length > 0) {
                    const source = gameState.streetData[0]?.source || 'fallback';
                    const isRegional = source === 'overpass-regional';
                    
                    if (isRegional) {
                        const completeRoads = gameState.streetData.filter(r => r.isComplete).length;
                        const breakdown = getStreetBreakdownByDifficulty();
                        const regionName = currentRegionalConfig?.name || '地域';
                        const strategyName = currentLoadingStrategy?.name || '標準';
                        
                        const fromCache = gameState.streetData.some(r => r.cached === true);
                        const cacheIcon = fromCache ? '💾' : '🌐';
                        
                        const bgStatus = backgroundLoadingActive ? '⏳ 追加読み込み中' : '';
                        
                        statusDiv.innerHTML = `
                            <div>${cacheIcon} ${regionName}道路ネットワーク (${strategyName})</div>
                            <div style="font-size: 0.7rem; margin-top: 0.3rem; color: #ccc;">
                                OSM: ${gameState.streetData.length} roads (${completeRoads} complete) ${bgStatus}
                                ${customStreetCount > 0 ? `| カスタム: ${customStreetCount} roads` : ''}
                            </div>
                            <div style="font-size: 0.65rem; margin-top: 0.2rem;">
                                OSM - Tourist: ${breakdown.tourist} | Resident: ${breakdown.resident} | Taxi: ${breakdown.taxi}
                            </div>
                            ${customStreetCount > 0 ? `
                            <div style="font-size: 0.65rem;">
                                カスタム - Tourist: ${customBreakdown.tourist} | Resident: ${customBreakdown.resident} | Taxi: ${customBreakdown.taxi}
                            </div>` : ''}
                        `;
                        statusDiv.style.background = '#2d5a2d';
                    } else {
                        const breakdown = getStreetBreakdownByDifficulty();
                        
                        statusDiv.innerHTML = `
                            <div>✅ ${gameState.streetData.length} streets loaded (${source === 'overpass' ? 'OSM data' : 'custom data'})</div>
                            ${customStreetCount > 0 ? `<div style="font-size: 0.7rem;">+ ${customStreetCount} custom streets</div>` : ''}
                            <div style="font-size: 0.7rem; margin-top: 0.3rem;">
                                OSM - Tourist: ${breakdown.tourist} | Resident: ${breakdown.resident} | Taxi: ${breakdown.taxi}
                            </div>
                            ${customStreetCount > 0 ? `
                            <div style="font-size: 0.7rem;">
                                カスタム - Tourist: ${customBreakdown.tourist} | Resident: ${customBreakdown.resident} | Taxi: ${customBreakdown.taxi}
                            </div>` : ''}
                        `;
                        statusDiv.style.background = source === 'overpass' ? '#2d5a2d' : '#5a4d2d';
                    }
                } else {
                    const strategyDesc = currentLoadingStrategy?.description || '';
                    
                    statusDiv.innerHTML = `
                        <div>⚠️ 道路データが読み込まれていません</div>
                        ${customStreetCount > 0 ? `<div style="font-size: 0.7rem;">カスタム道路: ${customStreetCount} available</div>` : ''}
                        <div style="font-size: 0.7rem; margin-top: 0.3rem; color: #ccc;">
                            選択中: ${currentLoadingStrategy?.name || '即座開始'}
                        </div>
                        <div style="font-size: 0.65rem; margin-top: 0.2rem;">
                            上の「Load Regional Roads」ボタンで読み込み開始
                        </div>
                    `;
                    statusDiv.style.background = '#5a2d2d';
                }
            }
        }

        function getStreetBreakdownByDifficulty() {
            if (!gameState.streetData) return { tourist: 0, resident: 0, taxi: 0 };

            const tourist = gameState.streetData.filter(q => DIFFICULTY_ALLOWED_TYPES['tourist'].includes(q.roadType)).length;
            const resident = gameState.streetData.filter(q => DIFFICULTY_ALLOWED_TYPES['resident'].includes(q.roadType)).length;
            const taxi = gameState.streetData.filter(q => DIFFICULTY_ALLOWED_TYPES['taxi-driver'].includes(q.roadType)).length;
            
            return { tourist, resident, taxi };
        }

        function getCustomStreetBreakdownByDifficulty() {
            const customStreets = gameState.customProblems.filter(p => p.type === 'street');
                        
            const tourist = customStreets.filter(q => {
                if (q.difficulty) return q.difficulty === 'tourist';
                return q.importance >= 80;
            }).length;
            
            const resident = customStreets.filter(q => {
                if (q.difficulty) return q.difficulty === 'resident';
                return q.importance >= 60 && q.importance < 80;
            }).length;
            
            const taxi = customStreets.filter(q => {
                if (q.difficulty) return q.difficulty === 'taxi-driver';
                return q.importance < 60;
            }).length;
            
            return { tourist, resident, taxi };
        }

        // Collect all segments of a road by name
        function gatherCompleteStreetSegments(roadName) {
            if (!gameState.streetData) return [];
            return gameState.streetData
                .filter(r => r.name === roadName)
                .flatMap(r => r.points);
        }

        function geocodeLocation(locationName) {
            return new Promise((resolve, reject) => {
                log('Geocoding location: ' + locationName);
                
                const coordPattern = /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/;
                const coordMatch = locationName.match(coordPattern);
                
                if (coordMatch) {
                    const lat = parseFloat(coordMatch[1]);
                    const lng = parseFloat(coordMatch[2]);
                    if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        resolve({ lat, lng, display_name: `${lat}, ${lng}` });
                        return;
                    }
                }
                
                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationName)}&limit=1`)
                    .then(response => response.json())
                    .then(data => {
                        if (data && data.length > 0) {
                            const result = data[0];
                            resolve({
                                lat: parseFloat(result.lat),
                                lng: parseFloat(result.lon),
                                display_name: result.display_name
                            });
                        } else {
                            reject(new Error('Location not found'));
                        }
                    })
                    .catch(error => {
                        log('Geocoding error: ' + error.message);
                        reject(error);
                    });
            });
        }

        function pickRandom(arr) {
            if (!Array.isArray(arr) || arr.length === 0) return null;
            return arr[Math.floor(Math.random() * arr.length)];
        }

        async function resolveNameToLocation(name, bbox = '35.5,139.4,35.9,139.9') {
            const query = `
                [out:json][timeout:10];
                (
                    node["name"="${name}"](${bbox});
                    way["name"="${name}"](${bbox});
                );
                out center 1;
            `;
            const res = await fetch("https://overpass-api.de/api/interpreter", {
                method: "POST",
                body: query
            });
            const data = await res.json();
            if (data.elements.length > 0) {
                const el = data.elements[0];
                const lat = el.lat || el.center?.lat;
                const lng = el.lon || el.center?.lon;
                if (lat && lng) return { lat, lng };
            }
            throw new Error(`"${name}" をOverpassから見つけられませんでした`);
        }

        function updateLocation() {
            const locationInput = document.getElementById('location');
            const locationValue = locationInput ? locationInput.value.trim() : '';
            
            if (!locationValue) {
                showWarning('Please enter a location');
                return;
            }
            
            log('Updating location to: ' + locationValue);
            
            const updateBtn = document.getElementById('update-location');
            let originalText = 'Update Location';
            if (updateBtn) {
                originalText = updateBtn.textContent;
                updateBtn.innerHTML = '<span class="loading"></span>Loading...';
                updateBtn.disabled = true;
                updateBtn.classList.add('loading');
            }
            
            geocodeLocation(locationValue)
                .then(result => {
                    gameState.center = { lat: result.lat, lng: result.lng };
                    
                    if (gameState.map) {
                        gameState.map.setView([result.lat, result.lng], 12);
                        updateGameArea();
                    }
                    
                    if (locationInput) {
                        locationInput.value = result.display_name.split(',').slice(0, 2).join(',');
                    }
                    
                    log('Location updated successfully to: ' + result.lat + ', ' + result.lng);
                    
                    setTimeout(() => {
                        const regionSelect = document.getElementById('region-select');
                        const strategySelect = document.getElementById('loading-strategy');
                        
                        const selectedRegion = regionSelect ? regionSelect.value : 'south-kanto';
                        const selectedStrategy = strategySelect ? strategySelect.value : 'immediate';
                        
                        loadRegionalRoadsOptimized(selectedRegion, selectedStrategy);
                    }, 500);
                })
                .catch(error => {
                    showWarning('Could not find location: ' + locationValue + '. Please try a different location.');
                    log('Location update failed: ' + error.message);
                })
                .finally(() => {
                    if (updateBtn) {
                        updateBtn.textContent = originalText;
                        updateBtn.disabled = false;
                        updateBtn.classList.remove('loading');
                    }
                });
        }

        // Location Services
        function getCurrentLocation() {
            const status = document.getElementById('location-status');
            if (status) {
                status.className = 'location-status pending';
                status.innerHTML = '<span class="loading"></span>Getting current location...';
                status.classList.remove('hidden');
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000
            };

            navigator.geolocation.getCurrentPosition(
                function(position) {
                    locationPermissionDenied = false;
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    
                    gameState.currentLocation = { lat, lng };
                    gameState.center = { lat, lng };
                    
                    if (gameState.map) {
                        gameState.map.setView([lat, lng], 14);
                        updateGameArea();
                    }
                    
                    const locationInput = document.getElementById('location');
                    if (locationInput) {
                        locationInput.value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    }
                    
                    if (status) {
                        status.className = 'location-status success';
                        status.textContent = '✅ Location updated to current position';
                    }
                    
                    setTimeout(() => {
                        const regionSelect = document.getElementById('region-select');
                        const strategySelect = document.getElementById('loading-strategy');
                        
                        const selectedRegion = regionSelect ? regionSelect.value : 'south-kanto';
                        const selectedStrategy = strategySelect ? strategySelect.value : 'immediate';
                        
                        loadRegionalRoadsOptimized(selectedRegion, selectedStrategy);
                    }, 1000);
                    
                    log(`Current location: ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
                },
                function(error) {
                    let message = 'Failed to get location: ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            message += 'Permission denied';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message += 'Position unavailable';
                            break;
                        case error.TIMEOUT:
                            message += 'Timeout';
                            break;
                        default:
                            message += 'Unknown error';
                            break;
                    }
                    
                    if (status) {
                        status.className = 'location-status error';
                        status.textContent = '❌ ' + message;
                    }
                    
                    locationPermissionDenied = true;
                    log('Geolocation error: ' + message);
                },
                options
            );
        }

        function promptInitialLocation() {
            if (gameState.initialLocationPrompted) return;
            gameState.initialLocationPrompted = true;

            if (!navigator.geolocation) {
                showWarning('Geolocation not supported');
                return;
            }

            const useCurrent = confirm('Center Locationを現在地に設定しますか?');
            if (useCurrent) {
                getCurrentLocation();
            } else {
                showInfo('Center Locationを設定し、Update Locationを押してください');
            }
        }

        function loadRegionalRoadsOptimized(regionKey = 'south-kanto', strategyKey = 'immediate') {
            return new Promise(async (resolve, reject) => {
                if (gameState.isLoadingData) {
                    log('Already loading data...');
                    resolve(false);
                    return;
                }
                
                const config = REGIONAL_CONFIGS[regionKey];
                const strategy = LOADING_STRATEGIES[strategyKey];
                
                if (!config || !strategy) {
                    reject(new Error('Invalid configuration'));
                    return;
                }
                
                currentRegionalConfig = config;
                currentLoadingStrategy = strategy;
                
                // Check cache first
                const cacheKey = `${regionKey}-${strategyKey}`;
                const cachedData = ROAD_CACHE.load(regionKey, strategyKey);
                if (cachedData && cachedData.length > 0) {
                    gameState.streetData = cachedData;
                    roadCache = gameState.streetData;
                    log(`Loaded ${cachedData.length} roads from cache`);
                    showSuccess(`✅ キャッシュから${cachedData.length}道路を読み込み完了！`);
                    updateDataStatus();
                    resolve(true);
                    return;
                }
                
                gameState.isLoadingData = true;
                
                const loadBtn = document.getElementById('load-street-data');
                if (loadBtn) {
                    loadBtn.textContent = 'Loading Roads...';
                    loadBtn.disabled = true;
                    loadBtn.classList.add('loading');
                }

                showLoading();
                
                log(`Loading roads with ${strategy.name} strategy for ${config.name}...`);
                
                // Multiple API endpoints with fallback
                const corsProxies = [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url=',
                    'https://cors-anywhere.herokuapp.com/'
                ];
                
                let lastError = null;
                let success = false;
                
                try {
                    const { south, west, north, east } = config.bbox;
                    const query = `
                    [out:json][timeout:60];
                    (
                        way["highway"]["name"](${south},${west},${north},${east});
                    );
                out geom;
                `;
                    
                    // Method 1: Try direct access first (might work in some environments)
                    try {
                        log('Attempting direct API access...');
                        const response = await fetch(OVERPASS_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                            body: `data=${encodeURIComponent(query)}`
                        });
                        if (response.ok) {
                            const data = await response.json();
                            const roads = processOverpassData(data);
                            if (roads.length > 0) {
                                gameState.streetData = roads;
                                roadCache = gameState.streetData;
                                ROAD_CACHE.save(regionKey, strategyKey, roads);
                                showSuccess(`✅ ${roads.length} roads loaded from OSM (direct)`);
                                updateDataStatus();
                                success = true;
                            }
                        }
                    } catch (directError) {
                        log('Direct API access failed: ' + directError.message);
                        lastError = directError;
                    }
                    
                    // Method 2: Try CORS proxies if direct access failed
                    if (!success) {
                        for (let i = 0; i < corsProxies.length && !success; i++) {
                            const proxy = corsProxies[i];
                            try {
                                log(`Attempting proxy ${i + 1}/${corsProxies.length}: ${proxy}`);
                                const proxyUrl = proxy + encodeURIComponent(OVERPASS_URL);
                                const response = await fetch(proxyUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                    body: `data=${encodeURIComponent(query)}`
                                });
                                
                                if (response.ok) {
                                    let data;
                                    const contentType = response.headers.get('content-type');
                                    const responseText = await response.text();
                                    
                                    log(`Proxy ${i + 1} response content-type: ${contentType}`);
                                    log(`Proxy ${i + 1} response preview: ${responseText.substring(0, 100)}...`);
                                    
                                    // Handle different response formats
                                    if (responseText.startsWith('<?xml') || responseText.includes('<osm')) {
                                        // XML response - skip this proxy
                                        log(`Proxy ${i + 1} returned XML instead of JSON, skipping...`);
                                        continue;
                                    }
                                    
                                    try {
                                        data = JSON.parse(responseText);
                                    } catch (parseError) {
                                        log(`Proxy ${i + 1} JSON parse failed: ${parseError.message}`);
                                        continue;
                                    }
                                    
                                    const roads = processOverpassData(data);
                                    if (roads.length > 0) {
                                        gameState.streetData = roads;
                                        roadCache = gameState.streetData;
                                        ROAD_CACHE.save(regionKey, strategyKey, roads);
                                        showSuccess(`✅ ${roads.length} roads loaded from OSM (proxy ${i + 1})`);
                                        updateDataStatus();
                                        success = true;
                                        break;
                                    }
                                }
                            } catch (proxyError) {
                                log(`Proxy ${i + 1} failed: ${proxyError.message}`);
                                lastError = proxyError;
                            }
                        }
                    }
                    
                    // Method 3: All external sources failed
                    if (!success) {
                        log('All external APIs failed.');
                        showError('OSMデータを取得できませんでした。インターネット接続または設定を確認してください。');
                        updateDataStatus();
                    }
                    
                } catch (err) {
                    console.error('Complete OSM load failure:', err);
                    
                    // Final fallback: report failure without sample data
                    log('Final fallback: Unable to retrieve road data from OSM');
                    showError('道路データを取得できませんでした。再度お試しください。');
                    updateDataStatus();
                } finally {
                    gameState.isLoadingData = false;
                    if (loadBtn) {
                        loadBtn.textContent = success ? '✅ Data Ready' : '🔄 Retry Load';
                        loadBtn.disabled = false;
                        loadBtn.classList.remove('loading');
                    }
                    hideLoading();
                    
                    // Always log final status
                    const finalCount = gameState.streetData ? gameState.streetData.length : 0;
                    const finalSource = gameState.streetData && gameState.streetData[0] ? gameState.streetData[0].source : 'none';
                    log(`Data loading complete: ${finalCount} roads from ${finalSource} source`);
                    
                    if (success && finalCount > 0) {
                        log('✅ Street mode is now ready for gameplay');
                        
                        // Show clear success message to user
                        setTimeout(() => {
                            const currentDataStatus = document.getElementById('data-status');
                            if (currentDataStatus && finalSource === 'fallback') {
                                currentDataStatus.style.border = '2px solid #4CAF50';
                                currentDataStatus.style.animation = 'pulse 2s ease-in-out';
                                setTimeout(() => {
                                    currentDataStatus.style.border = '';
                                    currentDataStatus.style.animation = '';
                                }, 3000);
                            }
                        }, 500);
                    }
                }

                resolve(success);
            });
        }

        function loadFacilityDataFromOverpass() {
            const { lat, lng } = gameState.center;
            const radius = gameState.range * 1000;
            const query = `
                [out:json][timeout:25];
                (
                    node["amenity"](around:${radius},${lat},${lng});
                );
                out body;
            `;
            fetch("https://overpass-api.de/api/interpreter", {
                method: "POST",
                body: query
            })
            .then(res => res.json())
            .then(data => {
                const facilities = data.elements
                    .filter(el => el.type === 'node' && el.tags && el.tags.name)
                    .map(el => ({
                        name: el.tags.name,
                        type: 'facility',
                        description: el.tags.amenity || '施設',
                        importance: 70,
                        points: [[{ lat: el.lat, lng: el.lon }]],
                        isEnclosedArea: false,
                        source: 'overpass'
                    }));
                facilityQuestions.push(...facilities);
                showSuccess(`${facilities.length} 件の施設データを取得しました`);
            })
            .catch(err => {
                showError('施設データ取得失敗: ' + err.message);
            });
        }

        function loadIntersectionDataFromOverpass() {
            const { lat, lng } = gameState.center;
            const radius = gameState.range * 1000;
            const query = `
                [out:json][timeout:25];
                (
                    node["highway"="traffic_signals"](around:${radius},${lat},${lng});
                    node["junction"="intersection"](around:${radius},${lat},${lng});
                );
                out body;
            `;
            fetch("https://overpass-api.de/api/interpreter", {
                method: "POST",
                body: query
            })
            .then(res => res.json())
            .then(data => {
                const intersections = data.elements
                    .filter(el => el.type === 'node')
                    .map(el => ({
                        name: el.tags.name || `交差点 (${el.id})`,
                        type: 'intersection',
                        description: el.tags.highway || el.tags.junction || '交差点',
                        importance: 65,
                        points: [[{ lat: el.lat, lng: el.lon }]],
                        source: 'overpass'
                    }));
                intersectionQuestions.push(...intersections);
                showSuccess(`${intersections.length} 件の交差点データを取得しました`);
            })
            .catch(err => {
                showError('交差点データ取得失敗: ' + err.message);
            });
        }
        
        // Calculate length of a single line segment array in meters
        function calculateWayLength(coords) {
            if (!coords || coords.length < 2) return 0;
            let total = 0;
            for (let i = 1; i < coords.length; i++) {
                if (typeof turf !== 'undefined') {
                    total += turf.distance(
                        turf.point([coords[i - 1].lng, coords[i - 1].lat]),
                        turf.point([coords[i].lng, coords[i].lat]),
                        { units: 'meters' }
                    );
                } else {
                    total += calculateSimpleDistance(
                        coords[i - 1].lat, coords[i - 1].lng,
                        coords[i].lat, coords[i].lng
                    ) * 1000;
                }
            }
            return total;
        }

        // Check if two segments are connected within a threshold (meters)
        function segmentsAreConnected(seg1, seg2, threshold = 50) {
            const ends1 = [seg1[0], seg1[seg1.length - 1]];
            const ends2 = [seg2[0], seg2[seg2.length - 1]];
            for (const p1 of ends1) {
                for (const p2 of ends2) {
                    const dist = typeof turf !== 'undefined'
                        ? turf.distance(
                            turf.point([p1.lng, p1.lat]),
                            turf.point([p2.lng, p2.lat]),
                            { units: 'meters' }
                        )
                        : calculateSimpleDistance(p1.lat, p1.lng, p2.lat, p2.lng) * 1000;
                    if (dist <= threshold) return true;
                }
            }
            return false;
        }

        // Cluster segments that are close to each other
        function clusterSegments(segments, threshold = 50) {
            const clusters = [];
            segments.forEach(seg => {
                let added = false;
                for (const cluster of clusters) {
                    if (cluster.some(s => segmentsAreConnected(s, seg, threshold))) {
                        cluster.push(seg);
                        added = true;
                        break;
                    }
                }
                if (!added) clusters.push([seg]);
            });
            return clusters;
        }

        function shouldExcludeWayGroup(segGroup) {
            const totalLength = segGroup.reduce((sum, coords) => sum + calculateWayLength(coords), 0);
            if (totalLength < 100) return true;
            if (totalLength < 200 && segGroup.length > 1) return true;
            return false;
        }

        // Helper function to process Overpass API data with length filtering
        function processOverpassData(data) {
            const rawWays = data.elements
                .filter(el => el.type === 'way' && el.geometry && el.tags && el.tags.name)
                .filter(el => {
                    const h = el.tags.highway;
                    const isExpressway = ['motorway', 'motorway_link', 'trunk_link'].includes(h);
                    const isBridge = el.tags.bridge === 'yes';
                    const isTunnel = el.tags.tunnel === 'yes';
                    const name = el.tags.name || '';
                    const hasBridgeName = /橋/.test(name);
                    const hasTunnelName = /トンネル/.test(name);
                    return !(isExpressway && (isBridge || isTunnel || hasBridgeName || hasTunnelName));
                })
                .map(el => ({
                    name: el.tags.name,
                    roadType: el.tags.highway,
                    points: el.geometry.map(p => ({ lat: p.lat, lng: p.lon }))
                }));

            const grouped = {};
            rawWays.forEach(w => {
                if (!grouped[w.name]) grouped[w.name] = [];
                grouped[w.name].push(w);
            });

            const results = [];
            Object.keys(grouped).forEach(name => {
                const ways = grouped[name];
                const segs = ways.map(w => w.points);
                const clusters = clusterSegments(segs);

                let bestType = ways[0].roadType;
                const allSegments = [];

                ways.forEach(w => {
                    if ((ROAD_TYPE_SCORES[w.roadType] || 0) > (ROAD_TYPE_SCORES[bestType] || 0)) {
                        bestType = w.roadType;
                    }
                });

                clusters.forEach(cluster => {
                    if (shouldExcludeWayGroup(cluster)) return;
                    allSegments.push(...cluster.map(seg => seg));
                });

                if (allSegments.length > 0) {
                    results.push({
                        name,
                        roadType: bestType,
                        points: allSegments,
                        importance: ROAD_TYPE_SCORES[bestType] || 40,
                        isComplete: true,
                        source: 'overpass'
                    });
                }
            });

            return results;
        }

        function isWithinGameArea(lat, lng) {
            try {
                if (typeof turf !== 'undefined') {
                    const point = turf.point([lng, lat]);
                    const center = turf.point([gameState.center.lng, gameState.center.lat]);
                    const distance = turf.distance(center, point, { units: 'kilometers' });
                    return distance <= gameState.range;
                } else {
                    const R = 6371;
                    const dLat = (lat - gameState.center.lat) * Math.PI / 180;
                    const dLng = (lng - gameState.center.lng) * Math.PI / 180;
                    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                             Math.cos(gameState.center.lat * Math.PI / 180) * Math.cos(lat * Math.PI / 180) *
                             Math.sin(dLng/2) * Math.sin(dLng/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    const distance = R * c;
                    return distance <= gameState.range;
                }
            } catch (error) {
                log('Error checking game area: ' + error.message);
                return true;
            }
        }

        function filterQuestionsByDifficulty(questions) {
            if (!questions || questions.length === 0) return [];

            let filtered = questions.filter(q => {
                const point = q.points[0][0];
                return isWithinGameArea(point.lat, point.lng);
            });

            const allowed = DIFFICULTY_ALLOWED_TYPES[gameState.difficulty] || DIFFICULTY_ALLOWED_TYPES['taxi-driver'];
            let typeFiltered = filtered.filter(q => allowed.includes(q.roadType));

            if (typeFiltered.length === 0) {
                log(`No streets found for ${gameState.difficulty} difficulty, using all streets`);
                typeFiltered = filtered;
            }

            typeFiltered.sort((a, b) => b.importance - a.importance);

            const maxPoolSize = {
                'tourist': 50,
                'resident': 150,
                'taxi-driver': 300
            };

            const finalFiltered = typeFiltered.slice(0, maxPoolSize[gameState.difficulty] || 150);

            log(`Final filtered result for ${gameState.difficulty}: ${finalFiltered.length} streets`);

            return finalFiltered;
        }

        function filterQuestionsByDifficultyCustom(questions) {
            if (!questions || questions.length === 0) return [];
            
            // Filter by location first
            let filtered = questions.filter(q => {
                const point = q.points[0][0];
                return isWithinGameArea(point.lat, point.lng);
            });
            
            // Filter by difficulty setting
            if (gameState.difficulty === 'tourist') {
                filtered = filtered.filter(q => {
                    // If question has explicit difficulty, use it
                    if (q.difficulty) {
                        return q.difficulty === 'tourist';
                    }
                    // Otherwise fall back to importance
                    return q.importance >= 80;
                });
            } else if (gameState.difficulty === 'resident') {
                filtered = filtered.filter(q => {
                    if (q.difficulty) {
                        return q.difficulty === 'resident' || q.difficulty === 'tourist';
                    }
                    return q.importance >= 60;
                });
            } else { // taxi-driver
                // All questions are eligible for taxi driver
                filtered = filtered.filter(q => {
                    if (q.difficulty) {
                        return true; // All difficulties allowed
                    }
                    return q.importance >= 40;
                });
            }
            
            log(`Custom questions filtered for ${gameState.difficulty}: ${filtered.length} questions`);
            return filtered;
        }

        async function startGame() {
            try {
                log('Starting game...');
                saveSetting('boh_lastLocation', gameState.center);
                
                if (gameState.currentMode === 'street') {
                    const hasCustom = gameState.customProblems.some(p => p.type === 'street');
                    const hasOSM = gameState.streetData && gameState.streetData.length > 0;
                    if (!hasCustom && !hasOSM) {
                        showWarning('Streetモードでは事前に「Load Regional Roads」でデータを読み込んでください。');
                        return;
                    } else if (hasCustom && !hasOSM) {
                        log('Streetモード: カスタムのみで即開始 → 背景でOverpassロード開始');
                        const regionSelect = document.getElementById('region-select');
                        const strategySelect = document.getElementById('loading-strategy');
                        const selectedRegion = regionSelect ? regionSelect.value : 'south-kanto';
                        const selectedStrategy = strategySelect ? strategySelect.value : 'immediate';
                        loadRegionalRoadsOptimized(selectedRegion, selectedStrategy);
                    }
                }

                if (gameState.currentMode === 'facility') {
                    const hasCustom = gameState.customProblems.some(p => p.type === 'facility');
                    if (!hasCustom && facilityQuestions.length < 3) {
                        log('施設モード: デフォルト or カスタム不足 → Overpassロード');
                        loadFacilityDataFromOverpass();
                    }
                }

                if (gameState.currentMode === 'intersection') {
                    const hasCustom = gameState.customProblems.some(p => p.type === 'intersection');
                    if (!hasCustom && intersectionQuestions.length < 3) {
                        log('交差点モード: デフォルト or カスタム不足 → Overpassロード');
                        loadIntersectionDataFromOverpass();
                    }
                }

                if (gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') {
                    const targetInput = document.getElementById('speedrun-target');
                    if (targetInput) {
                        const val = parseInt(targetInput.value, 10);
                        if (!isNaN(val) && val > 0) {
                            gameState.speedRun.targetCount = val;
                            saveSetting('geotextbook_speedrun_targetCount', val);
                        }
                    }
                    const tolInput = document.getElementById('speedrun-tolerance');
                    if (tolInput) {
                        const valTol = parseFloat(tolInput.value);
                        if (!isNaN(valTol) && valTol > 0) {
                            gameState.speedRun.toleranceMultiplier = valTol;
                            saveSetting('geotextbook_speedrun_toleranceMultiplier', valTol);
                        }
                    }
                    gameState.speedRun.bestTime = loadSetting('geotextbook_speedrun_bestTime', null);
                    const areaSelect = document.getElementById('geotextbook-area-select');
                    gameState.geotextbookArea = areaSelect ? areaSelect.value : gameState.geotextbookArea;
                    const orderSelect = document.getElementById('geotextbook-play-order');
                    gameState.playOrder = orderSelect ? orderSelect.value : 'random';
                    saveSetting('geotextbook_playOrder', gameState.playOrder);
                    gameState.speedRun.active = (gameState.playOrder === 'random');
                    if (gameState.currentMode === 'geotextbook') {
                        await loadGeotextbookFacilities(gameState.geotextbookArea);
                    } else {
                        await loadGeotextbookIntersections(gameState.geotextbookArea);
                    }
                    if (gameState.playOrder === 'registration') {
                        // 施設/交差点で別々の登録リストを想定しているなら切替する
                        const userList = (gameState.currentMode === 'geotextbook')
                            ? loadUserRegisteredFacilities()
                            : (window.loadUserRegisteredIntersections ? loadUserRegisteredIntersections() : []);
                        // 空なら geotextbook* をまるごと使う
                        const preset = (gameState.currentMode === 'geotextbook')
                            ? gameState.geotextbookFacilities
                            : gameState.geotextbookIntersections;
                        gameState.registrationList = userList.length
                            ? userList
                            : preset.slice();
                        gameState.registrationIndex = 0;
                        gameState.totalRetryCount = 0;
                        gameState.retryCountPerQuestion = gameState.registrationList.map(() => 0);
                        const preview = document.getElementById('registration-preview');
                        const listEl = document.getElementById('registration-list');
                        if (listEl) {
                            listEl.innerHTML = gameState.registrationList
                                .map((f,i) => `${i+1}. ${f.name}`)
                                .join('<br>');
                        }
                        if (preview) preview.style.display = 'block';
                    } else {
                        const preview = document.getElementById('registration-preview');
                        if (preview) preview.style.display = 'none';
                    }
                }

                if (gameState.currentMode === 'geotextbook-area') {
                    const areaSelect = document.getElementById('geotextbook-area-select');
                    gameState.geotextbookArea = areaSelect ? areaSelect.value : gameState.geotextbookArea;
                    await loadGeotextbookAreaFacilities(gameState.geotextbookArea);
                }
                
                gameState.isPlaying = true;
                gameState.score = 0;
                gameState.streak = 0;
                gameState.totalQuestions = 0;
                gameState.askedQuestions = [];

                if (gameState.speedRun.active) {
                    if (gameState.speedRun.timerInterval) {
                        clearInterval(gameState.speedRun.timerInterval);
                        gameState.speedRun.timerInterval = null;
                    }
                    gameState.speedRun.startTime = null;
                    gameState.speedRun.endTime = null;
                    gameState.speedRun.correctCount = 0;
                    const timerContainer = document.getElementById('speedrun-timer-container');
                    const progressContainer = document.getElementById('speedrun-progress-container');
                    if (timerContainer) timerContainer.style.display = 'block';
                    if (progressContainer) progressContainer.style.display = 'block';
                    updateSpeedRunUI();
                } else {
                    const timerContainer = document.getElementById('speedrun-timer-container');
                    const progressContainer = document.getElementById('speedrun-progress-container');
                    if (timerContainer) timerContainer.style.display = 'none';
                    if (progressContainer) progressContainer.style.display = 'none';
                }
                
                const challengeSection = document.getElementById('challenge-section');
                const startBtn = document.getElementById('start-game');
                const startControls = document.getElementById('start-controls');
                
                if (challengeSection) {
                    challengeSection.classList.remove('hidden');
                }
                if (startBtn) {
                    startBtn.style.display = 'none';
                }
                if (startControls) {
                    startControls.style.display = 'none';
                }
                
                updateMobileControls();
                
                if (gameState.map) {
                    gameState.map.invalidateSize();
                    setTimeout(() => {
                        gameState.map.invalidateSize();
                    }, 100);
                }
                
                // ゲーム開始時に街路名非表示（白地図）に切り替え
                if (gameState.showLabels) {
                    log('Auto-switching to no-labels mode for game start');
                    toggleLabels();
                }
                
                if (gameState.map) {
                    gameState.map.dragging.enable();
                    gameState.map.touchZoom.enable();
                    gameState.map.doubleClickZoom.enable();
                    gameState.map.scrollWheelZoom.enable();
                    gameState.map.boxZoom.enable();
                    gameState.map.keyboard.enable();
                }
                
                // モバイルゲームUIを表示
                showMobileGameUI();

                await nextQuestion();
                updateUI();
                
                log('Game started successfully - map interaction enabled');
            } catch (error) {
                log('Error starting game: ' + error.message);
                console.error('Start game error:', error);
            }
        }

        async function nextQuestion() {
            try {
                gameState.timerExpired = false; // タイムアウト処理初期化
                gameState.currentQuestion = null; // 安全のため初期化
                log('Loading next question...');
                
                clearGameElements();
                const timerEl = document.getElementById('timer');
                if (timerEl) timerEl.style.display = 'block';

                if ((gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') && gameState.playOrder === 'registration') {
                    if (gameState.registrationIndex >= gameState.registrationList.length) {
                        finishRegistrationMode();
                        return;
                    }
                    const facility = gameState.registrationList[gameState.registrationIndex];
                    gameState.totalQuestions = gameState.registrationIndex + 1;
                    gameState.currentQuestion = {
                        name: facility.name,
                        type: (gameState.currentMode === 'geotextbook') ? 'facility' : 'intersection',
                        description: facility.description || '登録施設',
                        importance: facility.importance || 50,
                        points: facility.points,
                        isEnclosedArea: facility.isEnclosedArea || false,
                        source: 'registration'
                    };
                    const questionTextEl = document.getElementById('question-text');
                    const questionTypeEl = document.getElementById('question-type');
                    if (questionTextEl) questionTextEl.textContent = `見つけてください: ${facility.name}`;
                    if (questionTypeEl) questionTypeEl.textContent = '登録順モード';
                    updateRegistrationProgress();
                    const showAnswerBtn = document.getElementById('show-answer');
                    if (showAnswerBtn) showAnswerBtn.classList.remove('hidden');
                    const gameBtnAnswer = document.getElementById('game-btn-answer');
                    if (gameBtnAnswer) gameBtnAnswer.classList.remove('hidden');
                    const distanceDisplay = document.getElementById('distance-display');
                    const nextBtn = document.getElementById('next-question');
                    const multipleChoice = document.getElementById('multiple-choice');
                    if (distanceDisplay) distanceDisplay.classList.add('hidden');
                    if (nextBtn) nextBtn.classList.add('hidden');
                    if (multipleChoice) multipleChoice.classList.add('hidden');
                    if (timerEl) {
                        timerEl.textContent = '-';
                        timerEl.style.display = 'none';
                    }
                    updateMobileQuestion(`🔎: ${facility.name}`, '登録順モード');
                    updateMobileControls();
                    return;
                }

                gameState.totalQuestions++;

                // 次の問題出題時に自動的に街路名非表示（白地図）に切り替え
                if (gameState.showLabels) {
                    log('Auto-switching to no-labels mode for next question');
                    toggleLabels();
                }

                if (!gameState.speedRun.active) {
                    gameState.timer = 30;
                    startTimer();
                }

                await generateNextQuestion();

                if (gameState.speedRun.active && !gameState.speedRun.startTime) {
                    gameState.speedRun.startTime = performance.now();
                    gameState.speedRun.timerInterval = setInterval(updateSpeedRunTimer, 100);
                    updateSpeedRunTimer();
                }
                if (gameState.speedRun.active) {
                    updateSpeedRunUI();
                }
                
                const distanceDisplay = document.getElementById('distance-display');
                const nextBtn = document.getElementById('next-question');
                const showAnswerBtn = document.getElementById('show-answer');
                const multipleChoice = document.getElementById('multiple-choice');
                
                if (distanceDisplay) distanceDisplay.classList.add('hidden');
                if (nextBtn) nextBtn.classList.add('hidden');
                if (showAnswerBtn) showAnswerBtn.classList.remove('hidden');
                if (multipleChoice) multipleChoice.classList.add('hidden');
                
                if (gameState.currentMode === 'reverse') {
                    showReverseChallenge();
                }
                
                updateUI();
                updateMobileControls();
                
                // 問題文を更新
                const questionText = gameState.currentMode === 'reverse' ? 
                    `強調表示された場所は何ですか？` : 
                    `🔎: ${gameState.currentQuestion?.name || ''}`;
                const questionType = `${getModeName(gameState.currentMode)}チャレンジ`;
                updateMobileQuestion(questionText, questionType);
                
                log('Next question loaded');
            } catch (error) {
                log('Error loading next question: ' + error.message);
                console.error('Next question error:', error);
            }
        }

        function getNextCustomProblem() {
            if (gameState.customProblems.length === 0) return null;
            const next =
                gameState.customProblems[gameState.customIndex % gameState.customProblems.length];
            gameState.customIndex += 1;
            return next;
        }

        async function generateQuestionFromCustom(problem) {
            try {
                const selectedQuestion = { ...problem, source: 'custom' };
                gameState.currentQuestion = selectedQuestion;
                gameState.askedQuestions.push(selectedQuestion);

                if (gameState.currentMode === 'street') {
                    const kmlData = await loadKmlIfExists(selectedQuestion.name, window.kmlMap);
                    if (!kmlData && gameState.skipMissingKml && gameState.customProblemsOnly) {
                        console.warn('⚠ カスタムKMLが見つからないためスキップ');
                        await generateNextQuestion();
                        return;
                    }
                    if (kmlData) {
                        selectedQuestion.points = kmlData.points;
                        selectedQuestion.source = 'kml';
                    }
                }

                const questionText = document.getElementById('question-text');
                const questionType = document.getElementById('question-type');

                if (questionText) {
                    questionText.textContent = gameState.currentMode === 'reverse'
                        ? `強調表示された場所は何ですか？`
                        : `見つけてください: ${selectedQuestion.name}`;
                }

                if (questionType) {
                    questionType.textContent = `${getModeName(gameState.currentMode)}チャレンジ (カスタム)`;
                }

                log(`Custom question generated: ${selectedQuestion.name}`);
            } catch (error) {
                log('Error generating custom question: ' + error.message);
                console.error('Custom question error:', error);
            }
        }

        async function generateNextQuestion() {
            if (gameState.customProblemsOnly) {
                const problem = getNextCustomProblem();
                if (problem) {
                    await generateQuestionFromCustom(problem);
                    return;
                }
            }
            await generateQuestion();
        }

        async function generateQuestion() {
            try {
                // 地理教本（施設/交差点）: まずここで処理して即 return
                if (gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') {
                    const pool = (gameState.currentMode === 'geotextbook')
                        ? (gameState.geotextbookFacilities || [])
                        : (gameState.geotextbookIntersections || []);
                    const candidate = pickRandom(pool);
                    if (!candidate || locationPermissionDenied) {
                        showWarning('地理教本データが利用できません。設定または位置情報を確認してください。');
                        return;
                    }
                    gameState.currentQuestion = {
                        name: candidate.name,
                        type: (gameState.currentMode === 'geotextbook') ? 'facility' : 'intersection',
                        description: (gameState.currentMode === 'geotextbook') ? '地理教本施設' : '地理教本交差点',
                        importance: 90,
                        points: candidate.points,
                        isEnclosedArea: false,
                        source: 'preset'
                    };
                    gameState.askedQuestions.push(gameState.currentQuestion);

                    const questionText = document.getElementById('question-text');
                    const questionType = document.getElementById('question-type');
                    if (questionText) {
                        questionText.textContent = `見つけてください: ${candidate.name}`;
                    }
                    if (questionType) {
                        questionType.textContent = `${getModeName(gameState.currentMode)}チャレンジ`;
                    }

                    log(`Question generated: ${candidate.name} (source: ${gameState.currentMode})`);
                    return;
                }

                // First collect all potential questions based on mode
                let osmQuestions = [];
                let customQuestions = [];

                switch (gameState.currentMode) {
                    case 'facility':
                        osmQuestions = facilityQuestions;
                        customQuestions = gameState.customProblems.filter(p => p.type === 'facility');
                        break;
                    case 'intersection':
                        osmQuestions = intersectionQuestions;
                        customQuestions = gameState.customProblems.filter(p => p.type === 'intersection');
                        break;
                    case 'reverse':
                        osmQuestions = [...facilityQuestions, ...intersectionQuestions];
                        customQuestions = gameState.customProblems.filter(p => p.type !== 'street');
                        break;
                    default: // street
                        osmQuestions = gameState.streetData || [];
                        customQuestions = gameState.customProblems.filter(p => p.type === 'street');

                        if (osmQuestions.length === 0 && customQuestions.length === 0) {
                            showWarning('No street data loaded yet. Please click "Load Regional Roads" to get actual OpenStreetMap data.');
                            return;
                        }
                }

                // Apply difficulty filtering separately to each source
                const filteredOsmQuestions = filterQuestionsByDifficulty(osmQuestions);
                const filteredCustomQuestions = filterQuestionsByDifficultyCustom(customQuestions);

                // Determine which source to use based on problemSource setting
                let sourcePool;
                if (gameState.problemSource === 'osm-only') {
                    sourcePool = filteredOsmQuestions;
                } else if (gameState.problemSource === 'custom-only') {
                    sourcePool = filteredCustomQuestions;
                } else { // mixed
                    // Use ratio to determine source
                    const useOsm = Math.random() < gameState.osmCustomRatio;

                    if (useOsm && filteredOsmQuestions.length > 0) {
                        sourcePool = filteredOsmQuestions;
                    } else if (!useOsm && filteredCustomQuestions.length > 0) {
                        sourcePool = filteredCustomQuestions;
                    } else {
                        // Fallback to whichever has questions
                        sourcePool = filteredOsmQuestions.length > 0 ? filteredOsmQuestions : filteredCustomQuestions;
                    }
                }

                if (!sourcePool || sourcePool.length === 0) {
                    showWarning('No questions available for the selected difficulty and source. Please adjust your settings.');
                    return;
                }

                // Filter out already asked questions
                const availableQuestions = sourcePool.filter(q =>
                    !gameState.askedQuestions.some(asked => asked.name === q.name)
                );

                let selectedQuestion;
                if (availableQuestions.length > 0) {
                    selectedQuestion = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
                } else {
                    // Reset asked questions if we've gone through all
                    gameState.askedQuestions = [];
                    selectedQuestion = sourcePool[Math.floor(Math.random() * sourcePool.length)];
                }

                gameState.currentQuestion = selectedQuestion;
                gameState.askedQuestions.push(selectedQuestion);

                if (gameState.currentMode === 'street') {
                    const kmlData = await loadKmlIfExists(selectedQuestion.name, window.kmlMap);
                    if (!kmlData && gameState.skipMissingKml && gameState.customProblemsOnly) {
                        console.warn('⚠ カスタムKMLが見つからないためスキップ');
                        await generateNextQuestion();
                        return;
                    }
                    if (kmlData) {
                        selectedQuestion.points = kmlData.points;
                        selectedQuestion.source = 'kml';
                    }
                }

                // Gather full road segments only for Overpass questions
                if (gameState.currentMode === 'street' &&
                    (selectedQuestion.source === 'overpass' || selectedQuestion.source === 'overpass-regional')) {
                    const fullSegments = gatherCompleteStreetSegments(selectedQuestion.name);
                    if (fullSegments && fullSegments.length > 0) {
                        selectedQuestion.fullPoints = fullSegments;
                    }
                }

                const questionText = document.getElementById('question-text');
                const questionType = document.getElementById('question-type');

                if (questionText) {
                    questionText.textContent = gameState.currentMode === 'reverse' ?
                        `強調表示された場所は何ですか？` :
                        `見つけてください: ${gameState.currentQuestion.name}`;
                }

                if (questionType) {
                    let sourceLabel = ' (OSM)';
                    if (gameState.currentQuestion.source === 'custom') {
                        sourceLabel = ' (カスタム)';
                    } else if (gameState.currentQuestion.source === 'kml') {
                        sourceLabel = ' (KML)';
                    }
                    questionType.textContent = `${getModeName(gameState.currentMode)}チャレンジ${sourceLabel}`;
                }

                log(`Question generated: ${gameState.currentQuestion.name} (source: ${gameState.currentQuestion.source || 'osm'})`);

            } catch (error) {
                log('Error generating question: ' + error.message);
                console.error('Generate question error:', error);
            }
        }

        // === 答え合わせ処理の交差点対応追加 ===
        async function showIntersectionAnswer(q) {
            // 交差点マーカー表示（大きめの赤い円）
            const intersectionMarker = L.circleMarker([q.points[0][0].lat, q.points[0][0].lng], {
                radius: 12,
                color: '#ff0000',
                fillColor: '#ff6b6b',
                fillOpacity: 0.8,
                weight: 3
            }).addTo(gameState.facilityLayer);

            // Google検索リンク
            const googleLink = `<a href="https://www.google.com/search?q=${encodeURIComponent(q.name)}" target="_blank">🔍 Google検索</a>`;

            // ハイライトレイヤーの初期化
            if (!gameState.highlightLayer) {
                gameState.highlightLayer = L.layerGroup().addTo(gameState.map);
            }
            gameState.highlightLayer.clearLayers();

            // 交差する道路を取得
            let roadNames = [];
            let roadInfo = [];
            const intersectionPoint = { lat: q.points[0][0].lat, lng: q.points[0][0].lng };
            
            try {
                // より広範囲で道路を検索（半径150m）
                const radius = 150;
                const query = `
                    [out:json][timeout:30];
                    (
                        way["highway"]["name"](around:${radius},${intersectionPoint.lat},${intersectionPoint.lng});
                    );
                    out body geom;
                `;
                
                log(`Fetching roads around intersection: ${q.name} at ${intersectionPoint.lat}, ${intersectionPoint.lng}`);
                
                const res = await fetch(OVERPASS_URL, {
                    method: "POST",
                    body: `data=${encodeURIComponent(query)}`,
                    headers: { "Content-Type": "application/x-www-form-urlencoded" }
                });
                
                if (!res.ok) {
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                
                const data = await res.json();
                log(`Retrieved ${data.elements?.length || 0} ways from Overpass`);
                
                // 交差点を通る道路を判定
                const threshold = 30; // 交差点から30m以内を通る道路を対象
                const seenRoads = new Set();
                
                data.elements?.forEach(el => {
                    if (el.type === "way" && el.tags?.name && el.geometry) {
                        const roadName = el.tags.name;
                        const highwayType = el.tags.highway;
                        
                        // 道路の重要度を判定
                        const importance = ROAD_TYPE_SCORES[highwayType] || 40;
                        
                        // 道路が交差点に近いかチェック
                        let minDistance = Infinity;
                        const coords = el.geometry.map(p => ({ lat: p.lat, lng: p.lon }));
                        
                        for (let i = 0; i < coords.length; i++) {
                            const distance = calculateSimpleDistance(
                                intersectionPoint.lat, intersectionPoint.lng,
                                coords[i].lat, coords[i].lng
                            ) * 1000; // メートルに変換
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                            }
                        }
                        
                        // 交差点に近い道路のみを対象
                        if (minDistance <= threshold && !seenRoads.has(roadName)) {
                            seenRoads.add(roadName);
                            roadInfo.push({
                                name: roadName,
                                type: highwayType,
                                importance: importance,
                                distance: minDistance,
                                coords: coords.map(p => [p.lat, p.lng])
                            });
                        }
                    }
                });
                
                // 重要度順にソート（主要道路を優先）
                roadInfo.sort((a, b) => b.importance - a.importance);
                
                // 上位の主要道路を取得（最大5本）
                const mainRoads = roadInfo.slice(0, 5);
                roadNames = mainRoads.map(r => r.name);
                
                log(`Found ${roadInfo.length} roads near intersection, showing ${mainRoads.length} main roads`);
                
                // 道路を地図上に色分けして表示
                mainRoads.forEach((road, index) => {
                    const colors = ['#FF5722', '#2196F3', '#4CAF50', '#FFC107', '#9C27B0'];
                    const color = colors[index % colors.length];
                    
                    L.polyline(road.coords, {
                        color: color,
                        weight: 6,
                        opacity: 0.7,
                        className: 'intersection-road'
                    }).addTo(gameState.highlightLayer);
                });
                
                // 交差点を中心にズーム
                gameState.map.setView([intersectionPoint.lat, intersectionPoint.lng], 16);
                
            } catch (err) {
                console.error("交差道路取得エラー:", err);
                log(`Error fetching intersection roads: ${err.message}`);
                
                // フォールバック：エラー時は交差点名から推測
                if (q.name && q.name.includes('交差点')) {
                    const parts = q.name.replace('交差点', '').split(/[・×]/);
                    if (parts.length > 1) {
                        roadNames = parts.map(p => p.trim()).filter(p => p);
                        log(`Fallback: extracted road names from intersection name: ${roadNames.join(', ')}`);
                    }
                }
            }

            // ポップアップ内容（詳細情報）
            const roadListHtml = roadNames.length > 0 
                ? `<ul style="margin: 0.5rem 0; padding-left: 1.5rem; text-align: left;">
                    ${roadNames.map(name => `<li>${name}</li>`).join('')}
                   </ul>`
                : '<p style="color: #999;">道路情報を取得できませんでした</p>';
            
            const popupHtml = `
                <div class="intersection-answer-popup" style="min-width: 250px;">
                    <h3 style="margin: 0.5rem 0; color: #ff6b6b;">${q.name}</h3>
                    <div style="margin: 0.5rem 0;">${googleLink}</div>
                    <div style="border-top: 1px solid #ddd; margin-top: 0.5rem; padding-top: 0.5rem;">
                        <strong>交差する主要道路:</strong>
                        ${roadListHtml}
                    </div>
                    ${q.description ? `<div style="margin-top: 0.5rem; font-size: 0.9em; color: #666;">${q.description}</div>` : ''}
                </div>
            `;
            
            intersectionMarker.bindPopup(popupHtml, {
                maxWidth: 350,
                className: 'intersection-popup'
            }).openPopup();
        }

        function showAnswer() {
            try {
                if (!gameState.currentQuestion) return;

                const question = gameState.currentQuestion;
                
                if (gameState.currentMode === 'street') {
                    const displaySegments = question.fullPoints || question.points;
                    setTimeout(() => {
                        displaySegments.forEach(segmentPoints => {
                            const latlngs = segmentPoints.map(p => [p.lat, p.lng]);
                            const line = L.polyline(latlngs, {
                                color: '#0f0',
                                weight: 8,
                                opacity: 0,
                                className: 'glow-line'
                            }).addTo(gameState.streetLayer);
                            line.on("click", function(e) {
                L.popup({ maxWidth: 450, className: "street-info-popup" })
                    .setLatLng(e.latlng)
                    .setContent(`<strong>${question.name}</strong> <a href="https://www.google.com/search?q=${encodeURIComponent(question.name)}" target="_blank">Google検索</a><br>${question.description}`)
                    .openOn(gameState.map);
            });
                            setTimeout(() => line.setStyle({ opacity: 1 }), 50);
                        });

                    }, 400);

                    // Adjust view based on street and circle size
                    adjustMapViewByStreetAndCircle(gameState.map, displaySegments, gameState.center, gameState.range);

                 // 「施設モード」と「地理教本施設モード」は同じ描画処理
                } else if (gameState.currentMode === 'facility' || gameState.currentMode === 'geotextbook') {
                    if (question.isEnclosedArea) {
                        const facilityArea = L.polygon(question.points[0], {
                            color: '#ff6b6b',
                            fillColor: '#ff6b6b',
                            fillOpacity: 0.4,
                            weight: 3
                        }).addTo(gameState.facilityLayer);
                    } else {
                        const facilityMarker = L.marker([question.points[0][0].lat, question.points[0][0].lng], {
                            icon: L.divIcon({
                                html: '<div style="background: #ff6b6b; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white;"></div>',
                                iconSize: [20, 20]
                            })
                        }).addTo(gameState.facilityLayer);
                    }

                    const point = question.points[0][0];
                    const query = encodeURIComponent(question.name);
                    const googleUrl = `https://www.google.com/search?q=${query}`;
                    L.popup()
                        .setLatLng([point.lat, point.lng])
                        .setContent(`
                            <strong>${question.name}</strong><br>
                            <a href="${googleUrl}" target="_blank" rel="noopener noreferrer">
                            Google検索
                            </a>
                        `)
                    .openOn(gameState.map);

                } else if (gameState.currentMode === 'intersection' || gameState.currentMode === 'geotextbook-intersection') {
                    showIntersectionAnswer(question);
                }

                const showAnswerBtn = document.getElementById('show-answer');
                const nextBtn = document.getElementById('next-question');
                const gameBtnAnswer = document.getElementById('game-btn-answer');
                
                if (showAnswerBtn) showAnswerBtn.classList.add('hidden');
                if (nextBtn) nextBtn.classList.remove('hidden');
                if (gameBtnAnswer) gameBtnAnswer.classList.add('hidden');
                
                stopTimer();
                log('Answer shown');
            } catch (error) {
                log('Error showing answer: ' + error.message);
                console.error('Show answer error:', error);
            }
        }

        function updateSpeedRunUI() {
            const progressEl = document.getElementById('speedrun-progress');
            const remainingEl = document.getElementById('speedrun-remaining');
            if (progressEl) {
                progressEl.textContent = `${gameState.speedRun.correctCount}/${gameState.speedRun.targetCount}`;
            }
            if (remainingEl) {
                const rem = gameState.speedRun.targetCount - gameState.speedRun.correctCount;
                remainingEl.textContent = `残り: あと ${rem} 問`;
            }
        }
        
        function formatSpeedRunTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        function updateSpeedRunTimer() {
            const timerEl = document.getElementById('speedrun-timer');
            if (!timerEl || !gameState.speedRun.startTime) return;
            const end = gameState.speedRun.endTime || performance.now();
            const elapsed = (end - gameState.speedRun.startTime) / 1000;
            timerEl.textContent = formatSpeedRunTime(elapsed);
        }

        function handleSpeedRunClick(userLatLng) {
            try {
                if (!gameState.currentQuestion) return;
                let distance;
                if (typeof turf !== 'undefined') {
                    const userPt = turf.point([userLatLng.lng, userLatLng.lat]);
                    const targetPt = turf.point([
                        gameState.currentQuestion.points[0][0].lng,
                        gameState.currentQuestion.points[0][0].lat
                    ]);
                    // distance in meters
                    distance = turf.distance(userPt, targetPt, { units: 'meters' });
                } else {
                    // fallback returns km, convert to meters
                    distance = calculateSimpleDistance(
                        userLatLng.lat,
                        userLatLng.lng,
                        gameState.currentQuestion.points[0][0].lat,
                        gameState.currentQuestion.points[0][0].lng
                    ) * 1000;
                }

                // tolerance in meters
                const tolerance = gameState.speedRun.baseToleranceKm *
                    gameState.speedRun.toleranceMultiplier * 1000;

                if (distance <= tolerance) {
                    gameState.speedRun.correctCount++;
                    updateSpeedRunUI();
                    showAnswer();

                    if (gameState.speedRun.correctCount >= gameState.speedRun.targetCount) {
                        gameState.speedRun.endTime = performance.now();
                        if (gameState.speedRun.timerInterval) {
                            clearInterval(gameState.speedRun.timerInterval);
                            gameState.speedRun.timerInterval = null;
                        }
                        updateSpeedRunTimer();
                        setTimeout(endGame, 800);
                    } else {
                        setTimeout(nextQuestion, 800);
                    }
                } else {
                    gameState.speedRun.endTime = performance.now();
                    if (gameState.speedRun.timerInterval) {
                        clearInterval(gameState.speedRun.timerInterval);
                        gameState.speedRun.timerInterval = null;
                    }
                    updateSpeedRunTimer();
                    endGame();
                }
            } catch (err) {
                console.error('Speedrun click error:', err);
            }
        }

        function loadUserRegisteredFacilities() {
            return loadSetting('user_registered_facilities', []);
        }

        function registrationProgressKey() {
            return `geotextbook_registration_index_${gameState.geotextbookArea}`;
        }

        function saveRegistrationProgress() {
            saveSetting(registrationProgressKey(), gameState.registrationIndex);
        }

        function clearRegistrationProgress() {
            localStorage.removeItem(registrationProgressKey());
        }

        function updateRegistrationProgress() {
            const progressEl = document.getElementById('question-progress');
            if (progressEl) {
                const total = gameState.registrationList.length;
                const current = Math.min(gameState.registrationIndex + 1, total);
                progressEl.textContent = `問 ${current}／登録済み ${total} 件`;
            }
        }

        function handleRegistrationClick(userLatLng) {
            try {
                const facility = gameState.registrationList[gameState.registrationIndex];
                if (!facility) return;
                const correctPoint = facility.points[0][0];
                let distance;
                if (typeof turf !== 'undefined') {
                    const userPt = turf.point([userLatLng.lng, userLatLng.lat]);
                    const targetPt = turf.point([correctPoint.lng, correctPoint.lat]);
                    distance = turf.distance(userPt, targetPt, { units: 'meters' });
                } else {
                    distance = calculateSimpleDistance(
                        userLatLng.lat, userLatLng.lng,
                        correctPoint.lat, correctPoint.lng
                    ) * 1000;
                }
                const tolerance = 25; // meters
                if (distance <= tolerance) {
                    // Correct: show answer only, progression handled by Next button
                    showAnswer();
                    if (facility.description) showMessage(facility.description, 'info-message');
                } else {
                    gameState.totalRetryCount++;
                    gameState.retryCountPerQuestion[gameState.registrationIndex] = (gameState.retryCountPerQuestion[gameState.registrationIndex] || 0) + 1;
                    showMessage('不正解です。もう一度挑戦してください。', 'warning-message');
                    if (gameState.registrationRetryLimit !== null && gameState.retryCountPerQuestion[gameState.registrationIndex] >= gameState.registrationRetryLimit) {
                        gameState.registrationIndex++;
                        saveRegistrationProgress();
                        if (gameState.registrationIndex < gameState.registrationList.length) {
                            showMessage('再挑戦上限に達しました。次の問題に移ります。', 'info-message');
                            setTimeout(() => nextQuestion(), gameState.registrationNextDelayMs);
                        } else {
                            finishRegistrationMode();
                        }
                    }
                }
            } catch (err) {
                console.error('Registration click error:', err);
            }
        }

        function handleRegistrationNext() {
            try {
                // Advance to the next registration question
                gameState.registrationIndex++;
                saveRegistrationProgress();
                if (gameState.registrationIndex < gameState.registrationList.length) {
                    nextQuestion();
                } else {
                    finishRegistrationMode();
                }
            } catch (err) {
                console.error('Registration next error:', err);
            }
        }

        function finishRegistrationMode() {
            gameState.isPlaying = false;
            const total = gameState.registrationList.length;
            const retries = gameState.totalRetryCount;
            const avg = total > 0 ? (retries / total).toFixed(2) : 0;
            const finalScoreEl = document.getElementById('final-score');
            const finalStatsEl = document.getElementById('final-stats');
            const resultsOverlay = document.getElementById('results-overlay');
            if (finalScoreEl) finalScoreEl.textContent = `全 ${total} 問完了！`;
            if (finalStatsEl) {
                finalStatsEl.innerHTML = `<div>再挑戦回数: ${retries} 回</div><div>平均再挑戦回数: ${avg} 回</div><div>正答率: 100%</div>`;
            }
            if (resultsOverlay) resultsOverlay.classList.remove('hidden');
            saveRegistrationHistory({ date: Date.now(), retries });
            clearRegistrationProgress();
            updateMobileControls();
        }

        function saveRegistrationHistory(entry) {
            const history = loadSetting('registration_history', []);
            history.push(entry);
            saveSetting('registration_history', history);
        }

        function handleMapClick(e) {
            try {
                const userLatLng = e.latlng;
                
                const advancedSettings = document.getElementById('advanced-settings');
                if (!gameState.settingsVisible && advancedSettings && !advancedSettings.classList.contains('hidden')) {
                    addPointFromMap(userLatLng.lat, userLatLng.lng);
                    return;
                }
                
                if (!gameState.isPlaying || gameState.currentMode === 'reverse') {
                    log('Map click ignored - not in playing mode or reverse mode');
                    return;
                }

                log('Map click at: ' + userLatLng.lat + ', ' + userLatLng.lng);
                
                if (!isWithinGameArea(userLatLng.lat, userLatLng.lng)) {
                    showWarning('クリック位置がゲームエリア外です。緑の円内をクリックしてください。');
                    return;
                }

                if ((gameState.currentMode === 'geotextbook' || gameState.currentMode === 'geotextbook-intersection') && gameState.playOrder === 'registration') {
                    handleRegistrationClick(userLatLng);
                    return;
                }

                if (gameState.speedRun.active) {
                    handleSpeedRunClick(userLatLng);
                    return;
                }

                gameState.lastGuess = userLatLng;

                let distance, accuracy, points;
                let calcResult = null; // for street mode

                if (gameState.currentMode === 'street') {
                    const segs = gameState.currentQuestion.fullPoints || gameState.currentQuestion.points;
                    if (typeof turf !== 'undefined') {
                        calcResult = calcErrorWithinCircle(
                            userLatLng,
                            segs,
                            gameState.center,
                            gameState.range
                        );
                        distance = calcResult.errorMeters;
                    } else {
                        distance = calculateDistanceToStreetTurf(userLatLng, segs.flat());
                    }
                } else {
                    if (typeof turf !== 'undefined') {
                        const userPoint = turf.point([userLatLng.lng, userLatLng.lat]);
                        const targetPoint = turf.point([
                            gameState.currentQuestion.points[0][0].lng,
                            gameState.currentQuestion.points[0][0].lat
                        ]);
                        distance = turf.distance(userPoint, targetPoint, { units: 'meters' });
                    } else {
                        distance = calculateSimpleDistance(
                            userLatLng.lat, userLatLng.lng,
                            gameState.currentQuestion.points[0][0].lat,
                            gameState.currentQuestion.points[0][0].lng
                        ) * 1000;
                    }
                }

                const distanceKm = (distance / 1000).toFixed(2);
               
                const maxDistance = 1000;
                // 25m以内なら100%、それ以上は距離から換算
                if (distance <= 25) {
                    accuracy = 100;
                } else {
                    accuracy = Math.max(0, 100 - (distance / maxDistance) * 100);
                }
                const baseScore = Math.round(accuracy);
                const timeBonus = Math.max(0, gameState.timer * 2);
                const streakBonus = gameState.streak * 5;
                
                if (accuracy >= 95) {
                    points = Math.round(baseScore * 1.5) + timeBonus + streakBonus;
                } else if (accuracy >= 80) {
                    points = Math.round(baseScore * 1.2) + timeBonus + streakBonus;
                } else {
                    points = baseScore + Math.round(timeBonus * 0.5) + streakBonus;
                }

                clearUserMarkers();

                gameState.userMarker = L.marker([userLatLng.lat, userLatLng.lng], {
                    icon: L.icon({
                        iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                        iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
                        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    })
                }).addTo(gameState.map);

                showAnswer();

                if (gameState.currentMode === 'street') {
                    const segs = gameState.currentQuestion.fullPoints || gameState.currentQuestion.points;
                    let nearestPoint;
                    if (typeof turf !== 'undefined') {
                        if (!calcResult) {
                            calcResult = calcErrorWithinCircle(
                                userLatLng,
                                segs,
                                gameState.center,
                                gameState.range
                            );
                        }
                        nearestPoint = calcResult.nearestPoint;
                    } else {
                        nearestPoint = findNearestPointOnStreetTurf(userLatLng, segs.flat());
                    }
                    if (nearestPoint) {
                        L.polyline([userLatLng, [nearestPoint[1], nearestPoint[0]]], {
                            color: '#2196F3',
                            weight: 2,
                            dashArray: '5, 5'
                        }).addTo(gameState.streetLayer);

                        setTimeout(() => {
                            gameState.correctMarker = L.circleMarker([nearestPoint[1], nearestPoint[0]], {
                                radius: 12,
                                color: '#f00',
                                fillOpacity: 0.6,
                                className: 'pulse-red'
                            }).addTo(gameState.streetLayer);
                        }, 1200);
                    }
                } else {
                    const correctLatLng = L.latLng(
                        gameState.currentQuestion.points[0][0].lat,
                        gameState.currentQuestion.points[0][0].lng
                    );
                    L.polyline([userLatLng, correctLatLng], {
                        color: '#2196F3',
                        weight: 2,
                        dashArray: '5, 5'
                    }).addTo(gameState.facilityLayer);
                }

                gameState.score += points;
                if (points > 90) {
                    gameState.streak++;
                } else {
                    gameState.streak = 0;
                }

                showResultModal(distance, accuracy);

                stopTimer();
                updateUI();
                updateMobileGameStats();

                log(`Answer processed: ${distanceKm}km, ${accuracy.toFixed(1)}% accuracy, ${points} points`);
            } catch (error) {
                log('Error handling map click: ' + error.message);
                console.error('Map click error:', error);
            }
        }

        function calculateDistanceToStreetTurf(userLatLng, streetPoints) {
            try {
                if (typeof turf !== 'undefined' && turf.nearestPointOnLine) {
                    const userPoint = turf.point([userLatLng.lng, userLatLng.lat]);
                    const lineString = turf.lineString(streetPoints.map(p => [p.lng, p.lat]));
                    const nearestPoint = turf.nearestPointOnLine(lineString, userPoint);
                    return turf.distance(userPoint, nearestPoint, { units: 'meters' });
                } else {
                    let minDistance = Infinity;
                    for (let i = 0; i < streetPoints.length; i++) {
                        const streetPoint = streetPoints[i];
                        const distance = calculateSimpleDistance(
                            userLatLng.lat, userLatLng.lng,
                            streetPoint.lat, streetPoint.lng
                        );
                        minDistance = Math.min(minDistance, distance);
                    }
                    return minDistance * 1000;
                }
            } catch (error) {
                log('Error calculating distance with Turf: ' + error.message);
                const targetPoint = streetPoints[0];
                return calculateSimpleDistance(
                    userLatLng.lat, userLatLng.lng,
                    targetPoint.lat, targetPoint.lng
                ) * 1000;
            }
        }

        function findNearestPointOnStreetTurf(userLatLng, streetPoints) {
            try {
                if (typeof turf !== 'undefined' && turf.nearestPointOnLine) {
                    const userPoint = turf.point([userLatLng.lng, userLatLng.lat]);
                    const lineString = turf.lineString(streetPoints.map(p => [p.lng, p.lat]));
                    const nearestPoint = turf.nearestPointOnLine(lineString, userPoint);
                    return nearestPoint.geometry.coordinates;
                } else {
                    let minDistance = Infinity;
                    let closestPoint = streetPoints[0];
                    for (let i = 0; i < streetPoints.length; i++) {
                        const distance = calculateSimpleDistance(
                            userLatLng.lat, userLatLng.lng,
                            streetPoints[i].lat, streetPoints[i].lng
                        );
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestPoint = streetPoints[i];
                        }
                    }
                    return [closestPoint.lng, closestPoint.lat];
                }
            } catch (error) {
                log('Error finding nearest point with Turf: ' + error.message);
                return [streetPoints[0].lng, streetPoints[0].lat];
            }
        }

        function calcErrorWithinCircle(userLatLng, allSegments, center, radiusKm) {
            try {
                if (typeof turf === 'undefined') {
                    const flat = Array.isArray(allSegments[0]) ? allSegments.flat() : allSegments;
                    const nearest = findNearestPointOnStreetTurf(userLatLng, flat);
                    const userPoint = turf.point([userLatLng.lng, userLatLng.lat]);
                    const targetPoint = turf.point(nearest);
                    const dist = turf.distance(userPoint, targetPoint, { units: 'meters' });
                    return { errorMeters: dist, nearestPoint: nearest };
                }

                const userPt = turf.point([userLatLng.lng, userLatLng.lat]);
                const circle = turf.circle([center.lng, center.lat], radiusKm, { units: 'kilometers', steps: 64 });

                const segArrays = Array.isArray(allSegments[0]) ? allSegments : [allSegments];

                const multi = turf.multiLineString(
                    segArrays.map(seg => seg.map(p => [p.lng, p.lat]))
                );

                let splits;
                try {
                    splits = turf.lineSplit(multi, circle).features;
                } catch (e) {
                    splits = [multi];
                }

                const inside = splits.filter(s => turf.booleanIntersects(s, circle));
                const candidates = inside.length > 0 ? inside : splits;

                let minDist = Infinity;
                let nearestPt = null;
                candidates.forEach(seg => {
                    const np = turf.nearestPointOnLine(seg, userPt);
                    const d = turf.distance(userPt, np, { units: 'meters' });
                    if (d < minDist) {
                        minDist = d;
                        nearestPt = np.geometry.coordinates;
                    }
                });

                return { errorMeters: minDist, nearestPoint: nearestPt };
            } catch (error) {
                log('Error calculating error within circle: ' + error.message);
                const flat = Array.isArray(allSegments[0]) ? allSegments.flat() : allSegments;
                const npAll = findNearestPointOnStreetTurf(userLatLng, flat);
                const userPoint = turf.point([userLatLng.lng, userLatLng.lat]);
                const targetPoint = turf.point(npAll);
                const dist = turf.distance(userPoint, targetPoint, { units: 'meters' });
                return { errorMeters: dist, nearestPoint: npAll };
            }
        }

    function calculateSimpleDistance(lat1, lng1, lat2, lng2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
    }

        // Adjust map view based on circle size
        function adjustMapViewByCircleSize(map, center, radiusKm) {
            let bounds;
            if (typeof turf !== 'undefined') {
                const circle = turf.circle([center.lng, center.lat], radiusKm, {
                    units: 'kilometers',
                    steps: 64
                });
                const circleBbox = turf.bbox(circle);
                bounds = L.latLngBounds(
                    [circleBbox[1], circleBbox[0]],
                    [circleBbox[3], circleBbox[2]]
                );
            } else {
                const circleObj = L.circle([center.lat, center.lng], { radius: radiusKm * 1000 });
                bounds = circleObj.getBounds();
            }
            if (radiusKm > 5) {
                map.fitBounds(bounds, { padding: [20, 20], maxZoom: 12 });
            } else if (radiusKm > 2) {
                map.fitBounds(bounds, { padding: [30, 30], maxZoom: 14 });
            } else {
                map.fitBounds(bounds, { padding: [50, 50], maxZoom: 16 });
            }
        }

        // Calculate total length of street segments in kilometers
        function calculateStreetLengthKm(segments) {
            let total = 0;
            segments.forEach(seg => {
                for (let i = 1; i < seg.length; i++) {
                    total += calculateSimpleDistance(
                        seg[i - 1].lat, seg[i - 1].lng,
                        seg[i].lat, seg[i].lng
                    );
                }
            });
            return total;
        }

        // Adjust map view considering street length and circle size
        function adjustMapViewByStreetAndCircle(map, segments, center, radiusKm) {
            const streetLenKm = calculateStreetLengthKm(segments);

            if (streetLenKm < radiusKm * 2) {
                const latlngs = segments.flat().map(p => [p.lat, p.lng]);
                const poly = L.polyline(latlngs);
                const bounds = poly.getBounds();

                const diagKm = calculateSimpleDistance(
                    bounds.getSouthWest().lat, bounds.getSouthWest().lng,
                    bounds.getNorthEast().lat, bounds.getNorthEast().lng
                );

                let maxZoom;
                if (diagKm > 10) {
                    maxZoom = 12;
                } else if (diagKm > 4) {
                    maxZoom = 14;
                } else {
                    maxZoom = 16;
                }

                map.fitBounds(bounds, { padding: [30, 30], maxZoom });
            } else {
                adjustMapViewByCircleSize(map, center, radiusKm);
            }
        }
        function clearGameElements() {
            try {
                clearUserMarkers();
                if (gameState.streetLayer) gameState.streetLayer.clearLayers();
                if (gameState.facilityLayer) gameState.facilityLayer.clearLayers();
                if (gameState.highlightLayer) gameState.highlightLayer.clearLayers();
                if (gameState.map) gameState.map.closePopup();
                hideMobileDistance();
                hideMobileChoices();
            } catch (error) {
                log('Error clearing game elements: ' + error.message);
            }
        }

        function clearUserMarkers() {
            try {
                if (gameState.userMarker && gameState.map) {
                    gameState.map.removeLayer(gameState.userMarker);
                    gameState.userMarker = null;
                }
                if (gameState.correctMarker && gameState.map) {
                    gameState.map.removeLayer(gameState.correctMarker);
                    gameState.correctMarker = null;
                }
            } catch (error) {
                log('Error clearing markers: ' + error.message);
            }
        }

        function startTimer() {
            try {
                stopTimer();
                gameState.timerInterval = setInterval(() => {
                    gameState.timer--;
                    updateTimer();
                    updateMobileGameStats();
                    
                    if (gameState.timer <= 0) {
                        handleTimeout();
                    }
                }, 1000);
            } catch (error) {
                log('Error starting timer: ' + error.message);
            }
        }

        function stopTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
        }

        function handleTimeout() {
            try {
                if (gameState.timerExpired) return;
                gameState.timerExpired = true;
                if (!gameState.currentQuestion || !gameState.currentQuestion.name) {
                    log('❌ No currentQuestion set on timeout. Skipping handling.');
                    return;
                }

                stopTimer();
                gameState.streak = 0;

                if (gameState.currentMode === 'reverse') {
                    showReverseAnswer();
                } else {
                    showAnswer();
                }

                updateUI();
                updateMobileGameStats();

                log('Timer expired');
            } catch (error) {
                log('Error handling timeout: ' + error.message);
            }
        }

        function showReverseAnswer(selectedName, isCorrect) {
            const correctName = gameState.currentQuestion?.name;

            document.querySelectorAll('.choice-button, .mobile-choice-btn').forEach(btn => {
                btn.disabled = true;
                btn.style.pointerEvents = 'none';
                if (btn.textContent === correctName) {
                    btn.classList.add('correct');
                } else if (selectedName && btn.textContent === selectedName) {
                    btn.classList.add('incorrect');
                }
            });

            const qOverlay = document.getElementById('game-question-overlay');
            if (qOverlay) qOverlay.classList.add('hidden');

            ['next-question', 'mobile-next', 'game-btn-next'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.classList.remove('hidden');
                    el.disabled = false;
                }
            });

            ['show-answer', 'mobile-answer', 'game-btn-answer'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });

            showReverseFeedback(selectedName || '', !!isCorrect, correctName);
            hideMobileChoices();
            updateUI();
            updateMobileGameStats();
        }

        function updateTimer() {
            const timerEl = document.getElementById('timer');
            const headerTimer = document.getElementById('header-timer');
            const mobileTimer = document.getElementById('mobile-timer');
            
            if (timerEl) {
                timerEl.textContent = gameState.timer;
            }
            
            if (headerTimer) {
                headerTimer.textContent = gameState.timer;
                headerTimer.classList.remove('warning', 'danger');
                
                if (gameState.timer <= 5) {
                    headerTimer.classList.add('danger');
                    timerEl.style.color = '#ff6b6b';
                    timerEl.classList.add('blinking');
                } else if (gameState.timer <= 10) {
                    headerTimer.classList.add('warning');
                    timerEl.style.color = '#ff9800';
                    timerEl.classList.remove('blinking');
                } else {
                    timerEl.style.color = '#4CAF50';
                    timerEl.classList.remove('blinking');
                }
            }
            
            updateMobileGameStats();
        }

        function updateUI() {
            try {
                const scoreEl = document.getElementById('score');
                const streakEl = document.getElementById('streak');
                const totalQuestionsEl = document.getElementById('total-questions');
                
                if (scoreEl) scoreEl.textContent = gameState.score;
                if (streakEl) streakEl.textContent = gameState.streak;
                if (totalQuestionsEl) totalQuestionsEl.textContent = gameState.totalQuestions;
            } catch (error) {
                log('Error updating UI: ' + error.message);
            }
        }

        function updateMobileControls() {
            const btnAnswer = document.getElementById('game-btn-answer');
            const btnEnd = document.getElementById('game-btn-end');

            if (gameState.isPlaying) {
                if (btnAnswer) btnAnswer.classList.remove('hidden');
                if (btnEnd) btnEnd.classList.remove('hidden');
            } else {
                if (btnAnswer) btnAnswer.classList.add('hidden');
                if (btnEnd) btnEnd.classList.add('hidden');
            }
        }

        function updateRangeDisplay() {
            const display = document.getElementById('range-display');
            if (display) {
                display.textContent = `${gameState.range} km`;
            }
        }

        function updateImportanceDisplay() {
            const slider = document.getElementById('problem-importance');
            const display = document.getElementById('importance-display');
            if (slider && display) {
                display.textContent = slider.value;
            }
        }

        function updateAutoDifficultyDisplay() {
            const importance = parseInt(document.getElementById('problem-importance').value);
            const display = document.getElementById('auto-difficulty-display');
            if (!display) return;

            let difficulty, difficultyText;
            if (importance >= 80) {
                difficulty = 'tourist';
                difficultyText = 'Tourist (Easy)';
            } else if (importance >= 60) {
                difficulty = 'resident';
                difficultyText = 'Resident (Medium)';
            } else {
                difficulty = 'taxi-driver';
                difficultyText = 'Taxi Driver (Hard)';
            }

            display.textContent = `自動判定: ${difficultyText}`;
            display.style.color = difficulty === 'tourist' ? '#4CAF50' : 
                                 difficulty === 'resident' ? '#ff9800' : '#f44336';
        }

        function showWarning(message) {
            showMessage(message, 'warning-message');
        }

        function showSuccess(message) {
            showMessage(message, 'success-message');
        }

        function showError(message) {
            showMessage(message, 'error-message');
        }

        function showInfo(message) {
            showMessage(message, 'info-message');
        }

        const loadingOverlay = document.getElementById('loading-overlay');

        function showLoading() {
            if (loadingOverlay) {
                loadingOverlay.style.display = 'flex';
            }
        }

        function hideLoading() {
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }

        function showMessage(message, className) {
            const sidebar = document.querySelector('.sidebar');
            const messageDiv = document.createElement('div');
            messageDiv.className = className;
            messageDiv.textContent = message;
            sidebar.insertBefore(messageDiv, sidebar.firstChild);

            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        function showReverseFeedback(selectedName, isCorrect, correctName) {
            const existing = document.getElementById('reverse-feedback-popup');
            if (existing) existing.remove();

            const popup = document.createElement('div');
            popup.id = 'reverse-feedback-popup';
            popup.style.position = 'absolute';
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.background = 'rgba(45, 45, 45, 0.95)';
            popup.style.padding = '1.5rem';
            popup.style.borderRadius = '12px';
            popup.style.color = 'white';
            popup.style.zIndex = '2000';
            popup.style.textAlign = 'center';
            popup.style.fontSize = '1rem';
            popup.style.backdropFilter = 'blur(10px)';
            popup.innerHTML = `
                <div style="font-size: 1.25rem; font-weight: bold; margin-bottom: 1rem;">
                    ${isCorrect ? '✅ 正解！' : '❌ 不正解'}
                </div>
                <div>あなたの選択: <strong>${selectedName}</strong></div>
                ${isCorrect ? '' : `<div>正しい答え: <strong>${correctName}</strong></div>`}
            `;

            document.body.appendChild(popup);

            setTimeout(() => popup.remove(), 5000);
        }

        function getModeName(mode) {
            const names = {
                'street': 'street',
                'facility': '施設',
                'intersection': '交差点',
                'reverse': '逆',
                'geotextbook': '地理教本施設',
                'geotextbook-intersection': '地理教本交差点',
            };
            return names[mode] || mode;
        }

        function showReverseChallenge() {
            try {
                if (!gameState.currentQuestion || !gameState.currentQuestion.points) {
                    log('❌ Invalid question: currentQuestion or points missing');
                    return;
                }
                const point = gameState.currentQuestion.points[0][0];
                const points = gameState.currentQuestion.points[0];
                const isPolygon = gameState.currentQuestion.isEnclosedArea && points.length >= 3;

                if (gameState.map) {
                    gameState.map.setView([point.lat, point.lng], 16, { animate: true });
                }

                if (isPolygon) {
                    L.polygon(points, {
                        className: 'blinking',
                        color: '#ff6b6b',
                        fillColor: '#ff6b6b',
                        fillOpacity: 0.4,
                        weight: 3
                    }).addTo(gameState.facilityLayer);
                } else {
                    L.circleMarker([point.lat, point.lng], {
                        radius: 18,
                        color: '#ff6b6b',
                        fillColor: '#ff6b6b',
                        fillOpacity: 0.8,
                        weight: 2,
                        className: 'blinking'
                    }).addTo(gameState.facilityLayer);
                }

                const choices = generateMultipleChoices();
                const choiceContainer = document.getElementById('multiple-choice');
                
                if (choiceContainer) {
                    choiceContainer.innerHTML = '';
                    choiceContainer.classList.remove('hidden');

                    choices.forEach((choice, index) => {
                        const button = document.createElement('button');
                        button.className = 'choice-button';
                        button.textContent = choice.name;
                        button.onclick = () => handleReverseAnswer(choice, button);
                        choiceContainer.appendChild(button);
                    });
                }

                showMobileChoices(choices);

                const showAnswerBtn = document.getElementById('show-answer');
                if (showAnswerBtn) {
                    showAnswerBtn.classList.add('hidden');
                }
                
                log('Reverse challenge shown');
            } catch (error) {
                log('Error showing reverse challenge: ' + error.message);
                console.error('Reverse challenge error:', error);
            }
        }

        function generateMultipleChoices() {
            try {
                const correct = gameState.currentQuestion;
                const allOptions = [...facilityQuestions, ...intersectionQuestions, ...gameState.customProblems.filter(p => p.type !== 'street')];
                const incorrectOptions = allOptions.filter(q => q.name !== correct.name);
                
                const shuffled = incorrectOptions.sort(() => 0.5 - Math.random());
                const choices = [correct, ...shuffled.slice(0, 3)];
                
                return choices.sort(() => 0.5 - Math.random());
            } catch (error) {
                log('Error generating choices: ' + error.message);
                return [gameState.currentQuestion];
            }
        }

        function handleReverseAnswer(selectedChoice, button) {
            try {
                const isCorrect = selectedChoice.name === gameState.currentQuestion.name;

                gameState.timerExpired = true; // 回答済みでタイマー停止
                stopTimer();

                // スコア処理
                if (isCorrect) {
                    const timeBonus = Math.max(0, gameState.timer * 2);
                    const baseScore = 100;
                    const streakBonus = gameState.streak * 10;
                    const totalScore = baseScore + timeBonus + streakBonus;

                    gameState.score += totalScore;
                    gameState.streak++;
                    log(`Correct answer! Score: ${totalScore} (base: ${baseScore}, time: ${timeBonus}, streak: ${streakBonus})`);
                } else {
                    gameState.streak = 0;
                    log('Incorrect answer');
                }

                showReverseAnswer(selectedChoice.name, isCorrect);
            } catch (error) {
                log('Error handling reverse answer: ' + error.message);
                console.error(error);
            }
        }


        function endGame() {
            try {
                log('Ending game...');

                gameState.isPlaying = false;
                stopTimer();

                hideMobileGameUI();

                // ゲーム終了時に街路名表示を復元
                if (!gameState.showLabels) {
                    log('Restoring labels display after game end');
                    toggleLabels();
                }

                const finalScoreEl = document.getElementById('final-score');
                const finalStatsEl = document.getElementById('final-stats');
                const resultsOverlay = document.getElementById('results-overlay');

                if (gameState.speedRun.active) {
                    if (gameState.speedRun.timerInterval) {
                        clearInterval(gameState.speedRun.timerInterval);
                        gameState.speedRun.timerInterval = null;
                    }
                    const totalSec = gameState.speedRun.startTime && gameState.speedRun.endTime
                        ? (gameState.speedRun.endTime - gameState.speedRun.startTime) / 1000
                        : 0;
                    const avgSec = gameState.speedRun.correctCount > 0
                        ? totalSec / gameState.speedRun.correctCount
                        : 0;
                    let best = loadSetting('geotextbook_speedrun_bestTime', null);
                    let bestNote = '';
                    if (gameState.speedRun.correctCount === gameState.speedRun.targetCount) {
                        if (best === null || totalSec < best) {
                            saveSetting('geotextbook_speedrun_bestTime', totalSec);
                            best = totalSec;
                            bestNote = ' (New!)';
                        }
                    }
                    const bestDisplay = best !== null ? formatSpeedRunTime(best) : '---';
                    if (finalScoreEl) {
                        finalScoreEl.textContent = `${gameState.speedRun.targetCount}問中${gameState.speedRun.correctCount}問正解`;
                    }
                    if (finalStatsEl) {
                        finalStatsEl.innerHTML = `
                            <div>総合タイム: ${formatSpeedRunTime(totalSec)}</div>
                            <div>平均解答時間: ${avgSec.toFixed(1)}秒</div>
                            <div>ベスト記録: ${bestDisplay}${bestNote}</div>
                        `;
                    }
                    if (resultsOverlay) {
                        resultsOverlay.classList.remove('hidden');
                    }
                    updateMobileControls();
                    log('Game ended');
                    return;
                }

                if (finalScoreEl) {
                    finalScoreEl.textContent = `Final Score: ${gameState.score}`;
                }

                saveSetting('boh_lastScore', gameState.score);
                saveSetting('boh_highScore', Math.max(gameState.score, loadSetting('boh_highScore', 0)));
                saveSetting('boh_lastLocation', gameState.center);

                if (finalStatsEl) {
                    const avgScore = gameState.totalQuestions > 0 ? Math.round(gameState.score / gameState.totalQuestions) : 0;
                    const maxStreak = gameState.streak;
                    const accuracy = gameState.totalQuestions > 0 ? Math.round((gameState.score / (gameState.totalQuestions * 150)) * 100) : 0;

                    finalStatsEl.innerHTML = `
                        <div>Questions Answered: ${gameState.totalQuestions}</div>
                        <div>Best Streak: ${maxStreak}</div>
                        <div>Average Score: ${avgScore} points per question</div>
                        <div>Overall Accuracy: ${accuracy}%</div>
                        <div>Game Mode: ${getModeName(gameState.currentMode)}</div>
                        <div>Difficulty: ${gameState.difficulty}</div>
                        <div>Range: ${gameState.range}km</div>
                    `;
                }

                if (resultsOverlay) {
                    resultsOverlay.classList.remove('hidden');
                }

                updateMobileControls();

                log('Game ended');
            } catch (error) {
                log('Error ending game: ' + error.message);
            }
        }

        function resetGame() {
            try {
                log('Resetting game...');
                
                gameState.isPlaying = false;
                gameState.score = 0;
                gameState.streak = 0;
                gameState.totalQuestions = 0;
                gameState.timer = 30;
                gameState.askedQuestions = [];
                
                clearGameElements();
                stopTimer();
                hideMobileGameUI();
                
                const challengeSection = document.getElementById('challenge-section');
                const resultsOverlay = document.getElementById('results-overlay');
                const startBtn = document.getElementById('start-game');
                const startControls = document.getElementById('start-controls');
                
                if (challengeSection) challengeSection.classList.add('hidden');
                if (resultsOverlay) resultsOverlay.classList.add('hidden');
                if (startBtn) startBtn.style.display = 'block';
                if (startControls) startControls.style.display = 'flex';
                const timerEl = document.getElementById('timer');
                if (timerEl) timerEl.style.display = 'block';
                const preview = document.getElementById('registration-preview');
                if (preview) preview.style.display = 'none';
                
                // ゲームリセット時に街路名表示を復元
                if (!gameState.showLabels) {
                    log('Restoring labels display after game reset');
                    toggleLabels();
                }
                
                updateMobileControls();
                
                updateUI();
                log('Game reset complete');
            } catch (error) {
                log('Error resetting game: ' + error.message);
            }
        }

        // Problem Editor Functions
        function addPointFromMap(lat, lng) {
            const advancedSettings = document.getElementById('advanced-settings');
            if (!advancedSettings || advancedSettings.classList.contains('hidden')) {
                return;
            }
            
            gameState.currentEditPoints.push({ lat, lng });
            updatePointsList();
            
            const marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'edit-point-marker',
                    html: '<div style="background: #2196F3; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                    iconSize: [12, 12]
                })
            }).addTo(gameState.facilityLayer);
            
            showInfo(`Point added: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
        }

        function updatePointsList() {
            const container = document.getElementById('current-points');
            
            if (gameState.currentEditPoints.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No points added yet</div>';
                return;
            }
            
            container.innerHTML = '';
            gameState.currentEditPoints.forEach((point, index) => {
                const pointDiv = document.createElement('div');
                pointDiv.className = 'point-item';
                pointDiv.innerHTML = `
                    <span class="point-coords">${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}</span>
                    <button class="point-remove" onclick="removePoint(${index})">Remove</button>
                `;
                container.appendChild(pointDiv);
            });
        }

        function removePoint(index) {
            gameState.currentEditPoints.splice(index, 1);
            updatePointsList();
            
            gameState.facilityLayer.clearLayers();
            gameState.currentEditPoints.forEach(point => {
                L.marker([point.lat, point.lng], {
                    icon: L.divIcon({
                        className: 'edit-point-marker',
                        html: '<div style="background: #2196F3; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                        iconSize: [12, 12]
                    })
                }).addTo(gameState.facilityLayer);
            });
        }

        function clearPoints() {
            gameState.currentEditPoints = [];
            updatePointsList();
            gameState.facilityLayer.clearLayers();
        }

        function saveProblem() {
            const name = document.getElementById('problem-name').value.trim();
            const type = document.getElementById('problem-type').value;
            const description = document.getElementById('problem-description').value.trim();
            const importance = parseInt(document.getElementById('problem-importance').value);
            
            if (!name) {
                showWarning('Please enter a problem name');
                return;
            }
            
            if (gameState.currentEditPoints.length === 0) {
                showWarning('Please add at least one point for this problem');
                return;
            }
            
            // Determine difficulty
            let difficulty;
            const difficultyMode = document.getElementById('problem-difficulty-mode').value;
            if (difficultyMode === 'manual') {
                difficulty = document.getElementById('problem-difficulty').value;
            } else {
                // Auto determine from importance
                if (importance >= 80) {
                    difficulty = 'tourist';
                } else if (importance >= 60) {
                    difficulty = 'resident';
                } else {
                    difficulty = 'taxi-driver';
                }
            }
            
            const problem = {
                name,
                type,
                description: description || `Custom ${type}`,
                importance,
                difficulty,  // New field
                points: [gameState.currentEditPoints.slice()],
                isEnclosedArea: gameState.currentEditPoints.length > 3 && type === 'facility',
                source: 'custom',
                id: Date.now()
            };
            
            if (gameState.editingProblem) {
                const index = gameState.customProblems.findIndex(p => p.id === gameState.editingProblem.id);
                if (index !== -1) {
                    gameState.customProblems[index] = problem;
                    problem.id = gameState.editingProblem.id;
                }
                gameState.editingProblem = null;
                showSuccess('Problem updated successfully!');
            } else {
                gameState.customProblems.push(problem);
                showSuccess('Problem saved successfully!');
            }
            
            saveCustomProblems();
            updateCustomProblemsList();
            clearProblemEditor();
        }

        function clearProblemEditor() {
            document.getElementById('problem-name').value = '';
            document.getElementById('problem-description').value = '';
            document.getElementById('problem-importance').value = '70';
            document.getElementById('problem-difficulty-mode').value = 'auto';
            document.getElementById('problem-difficulty').value = 'resident';
            document.getElementById('problem-difficulty').style.display = 'none';
            document.getElementById('auto-difficulty-display').style.display = 'block';
            updateImportanceDisplay();
            updateAutoDifficultyDisplay();
            clearPoints();
        }

        function updateCustomProblemsList() {
            const container = document.getElementById('custom-problems');
            
            if (gameState.customProblems.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No custom problems yet</div>';
                return;
            }
            
            container.innerHTML = '';
            gameState.customProblems.forEach(problem => {
                const problemDiv = document.createElement('div');
                problemDiv.className = 'problem-item';
                problemDiv.innerHTML = `
                    <div>
                        <div class="problem-name">${problem.name}</div>
                        <div class="problem-info">${problem.type} - Importance: ${problem.importance}</div>
                    </div>
                    <div class="problem-actions">
                        <button class="btn-small btn-edit" onclick="editProblem(${problem.id})">Edit</button>
                        <button class="btn-small btn-delete" onclick="deleteProblem(${problem.id})">Delete</button>
                    </div>
                `;
                container.appendChild(problemDiv);
            });
        }

        function editProblem(problemId) {
            const problem = gameState.customProblems.find(p => p.id === problemId);
            if (!problem) return;
            
            gameState.editingProblem = problem;
            
            document.getElementById('problem-name').value = problem.name;
            document.getElementById('problem-type').value = problem.type;
            document.getElementById('problem-description').value = problem.description;
            document.getElementById('problem-importance').value = problem.importance;
            updateImportanceDisplay();
            
            // Handle difficulty editing
            if (problem.difficulty) {
                document.getElementById('problem-difficulty-mode').value = 'manual';
                document.getElementById('problem-difficulty').value = problem.difficulty;
                document.getElementById('problem-difficulty').style.display = 'block';
                document.getElementById('auto-difficulty-display').style.display = 'none';
            } else {
                document.getElementById('problem-difficulty-mode').value = 'auto';
                document.getElementById('problem-difficulty').style.display = 'none';
                document.getElementById('auto-difficulty-display').style.display = 'block';
                updateAutoDifficultyDisplay();
            }
            
            gameState.currentEditPoints = problem.points[0].slice();
            updatePointsList();
            
            gameState.facilityLayer.clearLayers();
            gameState.currentEditPoints.forEach(point => {
                L.marker([point.lat, point.lng], {
                    icon: L.divIcon({
                        className: 'edit-point-marker',
                        html: '<div style="background: #2196F3; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                        iconSize: [12, 12]
                    })
                }).addTo(gameState.facilityLayer);
            });
            
            showInfo('Editing problem: ' + problem.name);
        }

        function deleteProblem(problemId) {
            if (confirm('Are you sure you want to delete this problem?')) {
                gameState.customProblems = gameState.customProblems.filter(p => p.id !== problemId);
                saveCustomProblems();
                updateCustomProblemsList();
                showInfo('Problem deleted');
            }
        }

        function saveCustomProblems() {
            try {
                const data = JSON.stringify(gameState.customProblems);
                localStorage.setItem('customProblems', data);
            } catch (error) {
                console.warn('Could not save custom problems:', error);
            }
        }

        function loadCustomProblems() {
            try {
                const data = localStorage.getItem('customProblems');
                if (data) {
                    gameState.customProblems = JSON.parse(data);
                    updateCustomProblemsList();
                }
            } catch (error) {
                console.warn('Could not load custom problems:', error);
                gameState.customProblems = [];
            }
        }

        async function loadGeotextbookFacilities(areaKey) {
            try {
                const config = GEOTEXTBOOK_AREA_CONFIGS[areaKey];
                if (!config) return;
                const response = await fetch(config.file);
                const rawData = await response.json();
                const facilities = [];
                for (const p of rawData) {
                    let lat = p.lat;
                    let lng = p.lng;
                    if ((lat == null || lng == null) && p.name) {
                        try {
                            const loc = await resolveNameToLocation(p.name, config.bbox);
                            lat = loc.lat;
                            lng = loc.lng;
                        } catch (err) {
                            console.warn('Overpass lookup failed for', p.name);
                        }
                    }
                    if (lat != null && lng != null) {
                        facilities.push({
                            name: p.name,
                            points: [[{ lat, lng }]],
                            description: p.description || '地理教本施設',
                            importance: p.importance || 50,
                            category: p.category || '',
                            source: 'area'
                        });
                    }
                }
                gameState.geotextbookFacilities = facilities;
                if (gameState.map && config.center) {
                    gameState.map.setView([config.center.lat, config.center.lng], 12);
                    updateGameArea();
                }
                log(`Geotextbook area ${config.name}: ${gameState.geotextbookFacilities.length}件ロード`);
            } catch (e) {
                log('Failed to load geotextbook facilities: ' + e.message);
                gameState.geotextbookFacilities = [];
            }
        }

        async function loadGeotextbookAreaFacilities(areaKey) {
            try {
                const config = GEOTEXTBOOK_AREA_CONFIGS[areaKey];
                if (!config) return;
                const response = await fetch(config.file);
                const rawData = await response.json();
                const valid = rawData.filter(p => p.lat && p.lng);
                gameState.geotextbookFacilities = valid.map(p => ({
                    name: p.name,
                    points: [[{ lat: p.lat, lng: p.lng }]],
                    description: p.description || '地理教本施設',
                    importance: p.importance || 50,
                    category: p.category || '',
                    source: 'area'
                }));
                if (gameState.map && config.center) {
                    gameState.map.setView([config.center.lat, config.center.lng], 12);
                    updateGameArea();
                }
                log(`Geotextbook area ${config.name}: ${gameState.geotextbookFacilities.length}件ロード`);
            } catch (e) {
                log('Failed to load geotextbook area facilities: ' + e.message);
                gameState.geotextbookFacilities = [];
            }
        }

        // KML Import Functions
        function handleKmlFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const kmlContent = e.target.result;
                    parseKmlData(kmlContent);
                } catch (error) {
                    showError('Failed to read KML file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function parseKmlData(kmlContent) {
            try {
                showInfo('Parsing KML data...');
                
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlContent, 'text/xml');
                
                const placemarks = kmlDoc.getElementsByTagName('Placemark');
                let importedCount = 0;
                
                for (let i = 0; i < placemarks.length; i++) {
                    const placemark = placemarks[i];
                    const name = placemark.getElementsByTagName('name')[0]?.textContent;
                    const description = placemark.getElementsByTagName('description')[0]?.textContent || '';
                    
                    if (!name) continue;
                    
                    const lineString = placemark.getElementsByTagName('LineString')[0];
                    const point = placemark.getElementsByTagName('Point')[0];
                    
                    let coordinates = null;
                    let problemType = 'facility';
                    
                    if (lineString) {
                        const coordsText = lineString.getElementsByTagName('coordinates')[0]?.textContent;
                        if (coordsText) {
                            coordinates = parseCoordinateString(coordsText);
                            problemType = 'street';
                        }
                    } else if (point) {
                        const coordsText = point.getElementsByTagName('coordinates')[0]?.textContent;
                        if (coordsText) {
                            coordinates = parseCoordinateString(coordsText);
                            problemType = 'facility';
                        }
                    }
                    
                    if (coordinates && coordinates.length > 0) {
                        // Auto-determine difficulty based on importance
                        let difficulty;
                        if (75 >= 80) {
                            difficulty = 'tourist';
                        } else if (75 >= 60) {
                            difficulty = 'resident';
                        } else {
                            difficulty = 'taxi-driver';
                        }
                        
                        const problem = {
                            name: name.trim(),
                            type: problemType,
                            description: description.trim() || `Imported ${problemType}`,
                            importance: 75,
                            difficulty: difficulty,  // Add difficulty field
                            points: [coordinates],
                            isEnclosedArea: false,
                            source: 'imported',
                            id: Date.now() + i
                        };
                        
                        gameState.customProblems.push(problem);
                        importedCount++;
                    }
                }
                
                if (importedCount > 0) {
                    saveCustomProblems();
                    updateCustomProblemsList();
                    showSuccess(`Successfully imported ${importedCount} problems from KML file!`);
                } else {
                    showWarning('No valid placemarks found in KML file');
                }
                
            } catch (error) {
                showError('Failed to parse KML: ' + error.message);
            }
        }

        function parseCoordinateString(coordsText) {
            const coordinates = [];
            const lines = coordsText.trim().split(/\s+/);
            
            for (const line of lines) {
                const parts = line.split(',');
                if (parts.length >= 2) {
                    const lng = parseFloat(parts[0]);
                    const lat = parseFloat(parts[1]);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        coordinates.push({ lat, lng });
                    }
                }
            }
            
            return coordinates;
        }

        // Background loading for remaining roads
        let backgroundLoadingActive = false;

        // Global functions for editor
        window.removePoint = removePoint;
        window.editProblem = editProblem;
        window.deleteProblem = deleteProblem;
        window.resetGame = resetGame;

        // Wait for required libraries to load
        async function waitForLibraries(maxAttempts = 50, interval = 100) {
            for (let i = 0; i < maxAttempts; i++) {
                const checks = window.checkLibrariesLoaded ? window.checkLibrariesLoaded() : {};
                if (checks.leaflet && checks.turf) {
                    return true;
                }
                await new Promise(r => setTimeout(r, interval));
            }
            return false;
        }

        // Initialize the game after libraries are ready
        window.addEventListener('load', function () {
            waitForLibraries().then(success => {
                if (!success) {
                    console.warn('Fallback turf functions activated');
                    window.turf = {
                        point: function(coords) {
                            return { geometry: { coordinates: coords, type: 'Point' } };
                        },
                        distance: function(from, to, options) {
                            const lat1 = from.geometry.coordinates[1];
                            const lon1 = from.geometry.coordinates[0];
                            const lat2 = to.geometry.coordinates[1];
                            const lon2 = to.geometry.coordinates[0];

                            const R = 6371;
                            const dLat = (lat2 - lat1) * Math.PI / 180;
                            const dLon = (lon2 - lon1) * Math.PI / 180;
                            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                                     Math.sin(dLon/2) * Math.sin(dLon/2);
                            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                            const distance = R * c;

                            return options && options.units === 'meters' ? distance * 1000 : distance;
                        },
                        lineString: function(coords) {
                            return { geometry: { coordinates: coords, type: 'LineString' } };
                        },
                        nearestPointOnLine: function(line, point) {
                            const coords = line.geometry.coordinates;
                            let minDist = Infinity;
                            let nearest = coords[0];

                            for (let i = 0; i < coords.length; i++) {
                                const dist = this.distance(
                                    { geometry: { coordinates: coords[i] } },
                                    point,
                                    { units: 'meters' }
                                );
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearest = coords[i];
                                }
                            }

                            return { geometry: { coordinates: nearest } };
                        },
                        midpoint: function(point1, point2) {
                            const lat1 = point1.geometry.coordinates[1];
                            const lon1 = point1.geometry.coordinates[0];
                            const lat2 = point2.geometry.coordinates[1];
                            const lon2 = point2.geometry.coordinates[0];

                            return {
                                geometry: {
                                    coordinates: [(lon1 + lon2) / 2, (lat1 + lat2) / 2]
                                }
                            };
                        }
                    };
                }
                if (typeof initGame === 'function') {
                    initGame();
                } else {
                    console.error('❌ initGame not defined.');
                }
            });
        });

        // Emergency initialization removed for faster startup

        window.addEventListener('resize', function() {
            if (gameState.map) {
                setTimeout(() => {
                    gameState.map.invalidateSize();
                    log('Map size invalidated after resize');
                }, 200);
            }
        });

        window.addEventListener('orientationchange', function() {
            log('Orientation changed, invalidating map size...');
            setTimeout(() => {
                if (gameState.map) {
                    gameState.map.invalidateSize();
                    if (window.innerWidth <= 768) {
                        gameState.map.setView(gameState.map.getCenter(), gameState.map.getZoom(), { animate: false });
                    }
                }
            }, 1000);
        });

        if ('ontouchstart' in window) {
            log('Touch device detected, applying touch optimizations...');
            
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(e) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }

        if ('onLine' in navigator) {
            window.addEventListener('online', function() {
                log('Network connection restored');
                if (!gameState.isMapInitialized) {
                    log('Attempting to reinitialize map...');
                    initGame();
                }
            });
            
            window.addEventListener('offline', function() {
                log('Network connection lost');
            });
        }

        if ('visibilityState' in document) {
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'visible') {
                    log('Page became visible, checking map state...');
                    if (gameState.map) {
                        setTimeout(() => {
                            gameState.map.invalidateSize();
                        }, 500);
                    }
                } else {
                    log('Page became hidden, pausing background operations...');
                }
            });
        }

        log('Enhanced Back of Your Hand game script loaded successfully');
        
        if (window.innerWidth <= 768) {
            log('Mobile device detected - Enhanced mobile mode enabled');
        }
    </script>
        <div id="reverse-question-overlay" class="hidden" style="
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(45, 45, 45, 0.95);
            padding: 2rem;
            border-radius: 12px;
            z-index: 1500;
            color: white;
            text-align: center;
            backdrop-filter: blur(10px);
            min-width: 280px;
            max-width: 90vw;
        ">
            <div style="font-size: 1.2rem; font-weight: bold; margin-bottom: 1rem;">
            強調表示された場所は何ですか？
        </div>
        <div class="reverse-choices" id="reverse-choices-container" style="display: grid; gap: 0.5rem; margin-bottom: 1rem;"></div>
        <button onclick="endGame()" style="background: #f44336; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px;">End</button>
    </div>
</body>
</html>