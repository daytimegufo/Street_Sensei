<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Back of Your Hand - Enhanced Map Challenge Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script>
        // ■問題エディタ用の保存関数（仮実装）
    function saveProblem() {
        log('saveProblem called');  // 実際の保存ロジックをここに実装
        // 例：ゲームステートに customProblems を追加して一覧を再描画
    }

    // ■地域道路読み込み用の関数（仮実装）
    async function loadRegionalRoadsOptimized(regionKey, strategyKey) {
        log(`loadRegionalRoadsOptimized: region=${regionKey}, strategy=${strategyKey}`);
        // 例：Overpass API を叩いて gameState.streetData に格納、
        //      updateDataStatus() を呼ぶ、などの実装をここに
    }
        // CDN fallback system
        window.leafletLoadAttempts = 0;
        window.checkLibrariesLoaded = function() {
            const leafletLoaded = typeof L !== 'undefined';
            const turfLoaded = typeof turf !== 'undefined';
            
            console.log(`Libraries check: Leaflet=${leafletLoaded}, Turf=${turfLoaded}`);
            
            if (!leafletLoaded && window.leafletLoadAttempts < 3) {
                window.leafletLoadAttempts++;
                console.log(`Retrying Leaflet load attempt ${window.leafletLoadAttempts}/3...`);
                
                // Try alternative CDN
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                script.onload = function() {
                    console.log('Leaflet loaded from alternative CDN');
                };
                script.onerror = function() {
                    console.error('Failed to load Leaflet from alternative CDN');
                };
                document.head.appendChild(script);
            }
            
            return { leaflet: leafletLoaded, turf: turfLoaded };
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .header {
            background: #2d2d2d;
            padding: 0.75rem 1rem;
            border-bottom: 2px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 70px;
            position: relative;
        }

        @media (max-width: 768px) {
            .header {
                height: 60px;
                padding: 0.5rem;
            }
        }

        .title {
            font-size: 1.25rem;
            font-weight: bold;
            color: #4CAF50;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 1rem;
            }
        }

        .stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.85rem;
        }

        @media (max-width: 768px) {
            .stats {
                gap: 0.75rem;
                font-size: 0.75rem;
                flex-wrap: wrap;
            }
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4CAF50;
        }

        @media (max-width: 768px) {
            .stat-value {
                font-size: 0.95rem;
            }
        }

        .menu-toggle {
            display: none;
            background: #4CAF50;
            border: none;
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
            }
        }

        .game-container {
            display: flex;
            height: calc(100vh - 70px);
        }

        @media (max-width: 768px) {
            .game-container {
                height: calc(100vh - 60px - 60px);
                flex-direction: column;
            }
        }

        .sidebar {
            width: 380px;
            background: #2d2d2d;
            border-right: 2px solid #444;
            padding: 1.25rem;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 60px;
                left: 0;
                width: 100vw;
                height: calc(100vh - 60px - 60px);
                z-index: 1000;
                transform: translateX(-100%);
                padding: 1rem;
            }

            .sidebar.open {
                transform: translateX(0);
            }
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
            background: #333;
            touch-action: manipulation;
        }

        .setup-section {
            margin-bottom: 1.5rem;
        }

        .setup-section h3 {
            margin-bottom: 0.75rem;
            color: #4CAF50;
            border-bottom: 1px solid #444;
            padding-bottom: 0.5rem;
            font-size: 1rem;
        }

        .form-group {
            margin-bottom: 0.75rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.9rem;
        }

        select, input, button, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #555;
            border-radius: 6px;
            background: #3d3d3d;
            color: #fff;
            font-size: 0.9rem;
            outline: none;
            transition: border-color 0.2s;
        }

        @media (max-width: 768px) {
            select, input, button, textarea {
                padding: 1rem;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px; /* Touch-friendly size */
            }
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        button:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #666 !important;
            cursor: not-allowed;
            opacity: 0.7;
        }

        button.loading {
            pointer-events: none;
        }

        .challenge-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #444;
        }

        .question-display {
            background: #3d3d3d;
            padding: 1.25rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            text-align: center;
        }

        .question-text {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .question-type {
            font-size: 0.85rem;
            color: #aaa;
        }

        .timer {
            font-size: 1.75rem;
            font-weight: bold;
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 1rem;
        }

        .distance-display {
            background: #3d3d3d;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            text-align: center;
        }

        .results-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(45, 45, 45, 0.95);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            min-width: 300px;
            backdrop-filter: blur(10px);
            max-width: 90vw;
        }

        .score-display {
            font-size: 1.75rem;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 1rem;
        }

        .multiple-choice {
            display: grid;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .choice-button {
            padding: 1rem;
            background: #3d3d3d;
            border: 1px solid #555;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }

        @media (max-width: 768px) {
            .choice-button {
                padding: 1.25rem;
                font-size: 1rem;
                min-height: 48px;
            }
        }

        .choice-button:hover {
            background: #4d4d4d;
            border-color: #4CAF50;
        }

        .choice-button.correct {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        .choice-button.incorrect {
            background: #f44336;
            border-color: #f44336;
        }

        .mode-tabs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            margin-bottom: 1rem;
            gap: 0.25rem;
        }

        .mode-tab {
            padding: 0.5rem;
            background: #3d3d3d;
            border: 1px solid #555;
            color: #aaa;
            cursor: pointer;
            font-size: 0.8rem;
            text-align: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        @media (max-width: 768px) {
            .mode-tab {
                padding: 0.75rem 0.5rem;
                font-size: 0.75rem;
                min-height: 48px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        .mode-tab.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .blinking {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .hidden {
            display: none !important;
        }

        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .map-control-btn {
            width: 44px;
            height: 44px;
            background: rgba(45, 45, 45, 0.9);
            border: 2px solid #4CAF50;
            color: #4CAF50;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        @media (max-width: 768px) {
            .map-control-btn {
                width: 50px;
                height: 50px;
                font-size: 1.4rem;
            }
        }

        .map-control-btn:hover {
            background: #4CAF50;
            color: white;
        }

        .layer-toggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(45, 45, 45, 0.9);
            border: 2px solid #4CAF50;
            color: #4CAF50;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        @media (max-width: 768px) {
            .layer-toggle {
                bottom: 70px;
                font-size: 0.75rem;
                padding: 1rem;
                min-height: 48px;
            }
        }

        .layer-toggle:hover {
            background: #4CAF50;
            color: white;
        }

        .debug-info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 1000;
            max-width: 90vw;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: middle;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message, .warning-message, .success-message, .info-message {
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .error-message {
            background: #f44336;
            color: white;
        }

        .warning-message {
            background: #ff9800;
            color: white;
        }

        .success-message {
            background: #4CAF50;
            color: white;
        }

        .info-message {
            background: #2196F3;
            color: white;
        }

        /* Advanced Settings Panel */
        .advanced-settings {
            margin-top: 1rem;
            padding: 1rem;
            background: #333;
            border-radius: 8px;
            border: 1px solid #555;
        }

        .advanced-settings h3 {
            color: #ff9800;
            margin-bottom: 1rem;
            font-size: 1rem;
            border-bottom: 1px solid #555;
            padding-bottom: 0.5rem;
        }

        .advanced-settings h4 {
            color: #4CAF50;
            margin: 1rem 0 0.5rem 0;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.25rem;
        }

        .editor-section {
            margin-bottom: 1.5rem;
        }

        .point-list {
            max-height: 150px;
            overflow-y: auto;
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.5rem;
        }

        .point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem;
            margin: 0.25rem 0;
            background: #4d4d4d;
            border-radius: 4px;
        }

        .point-coords {
            font-size: 0.8rem;
            color: #ccc;
        }

        .point-remove {
            background: #f44336;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.7rem;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            width: 100%;
            padding: 0.75rem;
            background: #2196F3;
            color: white;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .file-input-label:hover {
            background: #1976D2;
        }

        .problem-list {
            max-height: 200px;
            overflow-y: auto;
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.5rem;
        }

        .problem-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            margin: 0.25rem 0;
            background: #4d4d4d;
            border-radius: 4px;
        }

        .problem-name {
            font-weight: bold;
            color: #4CAF50;
        }

        .problem-info {
            font-size: 0.8rem;
            color: #ccc;
        }

        .problem-actions {
            display: flex;
            gap: 0.25rem;
        }

        .btn-small {
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            border-radius: 3px;
        }

        .btn-edit {
            background: #ff9800;
        }

        .btn-delete {
            background: #f44336;
        }

        .current-location-btn {
            background: #2196F3;
        }

        .current-location-btn:hover {
            background: #1976D2;
        }

        /* Location Services */
        .location-status {
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            text-align: center;
        }

        .location-status.success {
            background: #4CAF50;
            color: white;
        }

        .location-status.error {
            background: #f44336;
            color: white;
        }

        .location-status.pending {
            background: #ff9800;
            color: white;
        }

        /* Hide advanced settings on mobile */
        @media (max-width: 768px) {
            .advanced-settings {
                display: none !important;
            }
            
            /* Hide advanced tools button on mobile */
            #toggle-settings {
                display: none;
            }
        }

        /* Touch optimization */
        @media (hover: none) and (pointer: coarse) {
            .choice-button:hover,
            .mode-tab:hover,
            .map-control-btn:hover,
            .layer-toggle:hover {
                background: inherit;
                color: inherit;
                border-color: inherit;
                transform: none;
            }
        }

        /* Mobile Game Overlay - ゲーム中の地図上表示 */
        .mobile-game-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 900;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .mobile-game-overlay.active {
                display: block;
            }
        }

        /* ゲーム中の出題表示 - 地図上部固定 */
        .mobile-question-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background: rgba(45, 45, 45, 0.95);
            border-radius: 12px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .mobile-question-text {
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .mobile-question-type {
            color: #aaa;
            font-size: 0.8rem;
            text-align: center;
        }

        /* タイマーとスコア - 地図右上 */
        .mobile-game-stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(45, 45, 45, 0.9);
            border-radius: 8px;
            padding: 0.75rem;
            pointer-events: auto;
            min-width: 80px;
            text-align: center;
        }

        .mobile-timer {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 0.25rem;
        }

        .mobile-timer.warning {
            color: #ff9800;
        }

        .mobile-timer.danger {
            color: #ff6b6b;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .mobile-score {
            font-size: 0.8rem;
            color: #ccc;
        }

        /* 5択選択肢 - 地図下部 */
        .mobile-choices-overlay {
            position: absolute;
            bottom: 70px;
            left: 10px;
            right: 10px;
            pointer-events: auto;
        }

        .mobile-choices-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .mobile-choice-btn {
            background: rgba(45, 45, 45, 0.95);
            color: #fff;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 1rem 0.5rem;
            font-size: 0.9rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            word-wrap: break-word;
            hyphens: auto;
        }

        .mobile-choice-btn:active {
            transform: scale(0.95);
        }

        .mobile-choice-btn.correct {
            background: rgba(76, 175, 80, 0.9);
            border-color: #4CAF50;
        }

        .mobile-choice-btn.incorrect {
            background: rgba(244, 67, 54, 0.9);
            border-color: #f44336;
        }

        /* ゲーム結果表示 - 地図中央 */
        .mobile-result-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(45, 45, 45, 0.95);
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            min-width: 250px;
            max-width: 90%;
        }

        /* Bottom controls - スッキリしたデザイン */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(45, 45, 45, 0.95);
            backdrop-filter: blur(10px);
            border-top: 2px solid #444;
            padding: 0.75rem;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                justify-content: space-around;
                align-items: center;
            }
        }

        .mobile-control-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            min-width: 80px;
            transition: all 0.2s;
        }

        .mobile-control-btn:active {
            transform: scale(0.95);
        }

        .mobile-control-btn.secondary {
            background: #ff9800;
        }

        .mobile-control-btn.danger {
            background: #f44336;
        }

        /* ゲーム中はサイドバーを完全に隠す */
        .game-playing .sidebar {
            transform: translateX(-100%) !important;
        }

        /* ゲーム中のヘッダー簡素化 */
        @media (max-width: 768px) {
            .game-playing .header {
                height: 0;
                overflow: hidden;
                padding: 0;
            }

            .game-playing .game-container {
                height: 100vh;
            }

            .game-playing .mobile-controls {
                bottom: 0;
            }
        }

        /* 距離表示 - 地図左下 */
        .mobile-distance-overlay {
            position: absolute;
            bottom: 80px;
            left: 10px;
            background: rgba(45, 45, 45, 0.9);
            color: #fff;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.9rem;
            pointer-events: auto;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="menu-toggle" id="menu-toggle">☰</button>
        <div class="title">Back of Your Hand - Enhanced</div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="score">0</div>
                <div>Score</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="streak">0</div>
                <div>Streak</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="total-questions">0</div>
                <div>Questions</div>
            </div>
        </div>
    </div>

    <div class="game-container">
        <div class="sidebar" id="sidebar">
            <!-- Game Section (always visible) -->
            <div class="setup-section">
                <h3>Game Mode</h3>
                <div class="mode-tabs">
                    <div class="mode-tab active" data-mode="street">Street</div>
                    <div class="mode-tab" data-mode="facility">Facility</div>
                    <div class="mode-tab" data-mode="intersection">Intersection</div>
                    <div class="mode-tab" data-mode="reverse">Reverse</div>
                </div>
            </div>

            <div class="setup-section">
                <h3>Location & Range</h3>
                <div class="form-group">
                    <label for="location">Center Location</label>
                    <input type="text" id="location" placeholder="Enter city or coordinates" value="Tokyo, Japan">
                    <button id="update-location">Update Location</button>
                    <button id="get-current-location" class="current-location-btn">📍 Use Current Location</button>
                    <div id="location-status" class="location-status hidden"></div>
                </div>
                <div class="form-group">
                    <label for="range">Range: <span id="range-display">5 km</span></label>
                    <input type="range" id="range" min="1" max="50" value="5">
                </div>
            </div>

            <div class="setup-section">
                <h3>Difficulty</h3>
                <div class="form-group">
                    <select id="difficulty">
                        <option value="user-created-tokyo">🗾 ユーザー作成（東京都通称道路名）</option>
                        <option value="tourist">Tourist (Easy)</option>
                        <option value="resident">Resident (Medium)</option>
                        <option value="taxi-driver">Taxi Driver (Hard)</option>
                    </select>
                </div>
                <div class="form-group" id="user-created-options" style="display: none;">
                    <label for="kml-source">KMLファイルソース</label>
                    <select id="kml-source">
                        <option value="github">GitHub リポジトリ</option>
                        <option value="custom">カスタムファイル</option>
                        <option value="local">ローカルファイル</option>
                    </select>
                    <div id="github-options" style="margin-top: 0.5rem;">
                        <label for="kml-selection">道路選択 (複数選択可)</label>
                        <select id="kml-selection" multiple style="height: 120px;">
                            <option value="all">📍 全ての道路（GitHub: 149本）</option>
                            <option value="六本木通り">六本木通り</option>
                            <option value="靖国通り">靖国通り</option>
                            <option value="明治通り">明治通り</option>
                        </select>
                        <small style="color: #aaa; font-size: 0.75rem; display: block; margin-top: 0.25rem;">
                            Ctrl/Cmd+クリックで複数選択
                        </small>
                    </div>
                    <button id="load-user-kml" style="background: #2196F3; margin-top: 0.5rem;">📥 選択した道路データを読み込み</button>
                    <div id="user-kml-status" style="margin-top: 0.5rem; padding: 0.5rem; background: #444; border-radius: 4px; font-size: 0.8rem;">
                        💡 GitHub: daytimegufo/Street_Sensei から149本の東京都通称道路名を選択可能
                    </div>
                </div>
            </div>

            <div class="setup-section">
                <h3>Data Source</h3>
                <div class="form-group">
                    <label for="region-select">Regional Network</label>
                    <select id="region-select">
                        <option value="south-kanto">南関東全域 (Complete Network)</option>
                        <option value="tokyo-center">東京都心 (Center Only)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="loading-strategy">Loading Strategy</label>
                    <select id="loading-strategy">
                        <option value="immediate">⚡ 即座開始 (Fast Start)</option>
                        <option value="balanced">⚖️ バランス型 (Balanced)</option>
                        <option value="complete">🔄 完全読み込み (Complete)</option>
                    </select>
                    <small style="color: #aaa; font-size: 0.75rem; display: block; margin-top: 0.25rem;">
                        即座開始: 10秒で開始可能、他は必要時に読み込み
                    </small>
                </div>
            </div>

            <div class="setup-section">
                <button id="start-game">Start Game</button>
                <button id="load-street-data" style="background: #ff9800; font-size: 0.85rem; margin-top: 0.5rem;">🗺️ Load Regional Roads</button>
                <button id="toggle-settings" style="background: #666; font-size: 0.85rem; margin-top: 0.5rem;">🔧 Show Advanced Tools</button>
                <div id="data-status" style="margin-top: 0.5rem; padding: 0.5rem; background: #5a2d2d; border-radius: 4px; font-size: 0.8rem; color: white;">
                    ⚠️ Street mode requires regional data - click above to load complete road network
                </div>
            </div>

            <!-- Advanced Settings Panel (Hidden by default) -->
            <div class="advanced-settings hidden" id="advanced-settings">
                <div class="setup-section">
                    <h3>🔧 Advanced Tools (PC Only)</h3>
                    
                    <!-- Problem Editor -->
                    <div class="editor-section">
                        <h4>Problem Editor</h4>
                        <div class="form-group">
                            <label for="problem-name">Problem Name</label>
                            <input type="text" id="problem-name" placeholder="Enter street/facility name">
                        </div>
                        <div class="form-group">
                            <label for="problem-type">Problem Type</label>
                            <select id="problem-type">
                                <option value="street">Street</option>
                                <option value="facility">Facility</option>
                                <option value="intersection">Intersection</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="problem-description">Description</label>
                            <textarea id="problem-description" placeholder="Brief description of the location" rows="2"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="problem-importance">Importance (1-100)</label>
                            <input type="range" id="problem-importance" min="1" max="100" value="70">
                            <span id="importance-display">70</span>
                        </div>
                        
                        <h4>Location Points</h4>
                        <p style="font-size: 0.8rem; color: #aaa; margin-bottom: 0.5rem;">
                            Click on the map to add points for this problem
                        </p>
                        <div id="current-points" class="point-list">
                            <div style="text-align: center; color: #666;">No points added yet</div>
                        </div>
                        <button id="clear-points" style="background: #f44336; margin-top: 0.5rem;">Clear All Points</button>
                        
                        <div style="margin-top: 0.5rem;">
                            <button id="save-problem" style="background: #4CAF50;">Save Problem</button>
                            <button id="cancel-edit" style="background: #666; margin-top: 0.25rem;">Cancel</button>
                        </div>
                        
                        <h4>Custom Problems</h4>
                        <div id="custom-problems" class="problem-list">
                            <div style="text-align: center; color: #666;">No custom problems yet</div>
                        </div>
                    </div>

                    <!-- KML Import -->
                    <div class="editor-section">
                        <h4>Import KML Data</h4>
                        <div class="form-group">
                            <div class="file-input-wrapper">
                                <input type="file" id="kml-file" class="file-input" accept=".kml,.kmz">
                                <label for="kml-file" class="file-input-label">📁 Choose KML File</label>
                            </div>
                        </div>
                        <div id="import-status" class="hidden"></div>
                        
                        <h4>Sample KML Data</h4>
                        <p style="font-size: 0.8rem; color: #aaa; margin-bottom: 0.5rem;">
                            Load the provided Yamate-dori sample data:
                        </p>
                        <button id="load-sample-kml" style="background: #2196F3;">Load Yamate-dori Sample</button>
                        
                        <h4>Import Instructions</h4>
                        <div style="font-size: 0.8rem; color: #ccc; line-height: 1.4;">
                            <p><strong>Supported formats:</strong> KML files with LineString or Point geometries</p>
                            <p><strong>Required fields:</strong> Name (required), Description (optional)</p>
                            <p><strong>How to create KML:</strong></p>
                            <ul style="margin-left: 1rem; margin-top: 0.5rem;">
                                <li>Use Google My Maps to create custom maps</li>
                                <li>Draw lines for streets or place markers for facilities</li>
                                <li>Export as KML file</li>
                                <li>Import here to use in the game</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="challenge-section hidden" id="challenge-section">
                <div class="timer" id="timer">30</div>
                
                <div class="question-display">
                    <div class="question-text" id="question-text">Click on the map to locate:</div>
                    <div class="question-type" id="question-type">Street Challenge</div>
                </div>

                <div class="multiple-choice hidden" id="multiple-choice"></div>

                <div class="distance-display hidden" id="distance-display">
                    <div>Distance: <span id="distance">-</span></div>
                    <div>Accuracy: <span id="accuracy">-</span></div>
                </div>

                <button id="next-question" class="hidden">Next Question</button>
                <button id="show-answer" class="hidden" style="background: #ff9800;">Show Answer</button>
                <button id="end-game" style="background: #f44336;">End Game</button>
            </div>
        </div>

        <div class="map-container">
            <div id="map"></div>
            
            <!-- Mobile Game Overlay - モバイルゲーム用オーバーレイ -->
            <div class="mobile-game-overlay" id="mobile-game-overlay">
                <!-- 出題内容表示 -->
                <div class="mobile-question-overlay" id="mobile-question-overlay">
                    <div class="mobile-question-text" id="mobile-question-text">地図をタップして場所を特定してください</div>
                    <div class="mobile-question-type" id="mobile-question-type">道路チャレンジ</div>
                </div>

                <!-- タイマーとスコア -->
                <div class="mobile-game-stats" id="mobile-game-stats">
                    <div class="mobile-timer" id="mobile-timer">30</div>
                    <div class="mobile-score">
                        <div>Score: <span id="mobile-score">0</span></div>
                        <div>Streak: <span id="mobile-streak">0</span></div>
                    </div>
                </div>

                <!-- 5択選択肢 -->
                <div class="mobile-choices-overlay hidden" id="mobile-choices-overlay">
                    <div class="mobile-choices-grid" id="mobile-choices-grid">
                        <!-- 動的に生成される -->
                    </div>
                </div>

                <!-- 結果表示 -->
                <div class="mobile-distance-overlay hidden" id="mobile-distance-overlay">
                    <div>距離: <span id="mobile-distance">-</span></div>
                    <div>精度: <span id="mobile-accuracy">-</span></div>
                </div>
            </div>
            
            <div class="map-controls">
                <div class="map-control-btn" id="zoom-in" title="Zoom In">+</div>
                <div class="map-control-btn" id="zoom-out" title="Zoom Out">−</div>
            </div>
            
            <div class="layer-toggle" id="toggle-labels" title="Toggle Street Names">
                街路名表示/非表示
            </div>

            <div class="results-overlay hidden" id="results-overlay">
                <h2>Game Complete!</h2>
                <div class="score-display" id="final-score">Score: 0</div>
                <div id="final-stats"></div>
                <button onclick="resetGame()">Play Again</button>
            </div>

            <div class="debug-info" id="debug-info">Loading map...</div>
        </div>
    </div>

    <!-- Mobile Controls - 改善されたモバイルコントロール -->
    <div class="mobile-controls">
        <button class="mobile-control-btn" id="mobile-menu">📱 設定</button>
        <button class="mobile-control-btn secondary" id="mobile-answer" class="hidden">💡 答え</button>
        <button class="mobile-control-btn" id="mobile-next" class="hidden">▶️ 次へ</button>
        <button class="mobile-control-btn danger" id="mobile-end" class="hidden">🏁 終了</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <script>
        function log(message) {
            console.log(message);
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo) {
                const timestamp = new Date().toLocaleTimeString();
                debugInfo.innerHTML = `[${timestamp}] ${message}`;
                debugInfo.style.display = 'block';
                
                if (message.includes('successfully') || message.includes('ready')) {
                    setTimeout(() => {
                        debugInfo.style.display = 'none';
                    }, 3000);
                }
                
                if (message.includes('Error') || message.includes('Failed')) {
                    debugInfo.style.background = '#f44336';
                    debugInfo.style.color = 'white';
                } else if (message.includes('successfully') || message.includes('ready')) {
                    debugInfo.style.background = '#4CAF50';
                    debugInfo.style.color = 'white';
                } else {
                    debugInfo.style.background = 'rgba(0,0,0,0.8)';
                    debugInfo.style.color = 'white';
                }
            }
        }

        // Enhanced library loading check for Safari
        function checkLibraryLoading() {
            const checks = {
                leaflet: typeof L !== 'undefined',
                turf: typeof turf !== 'undefined',
                dom: document.readyState === 'complete'
            };
            
            log(`Library check: Leaflet=${checks.leaflet}, Turf=${checks.turf}, DOM=${checks.dom}`);
            
            // Safari specific debugging
            if (navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome')) {
                log('Safari detected - applying Safari-specific optimizations');
                // Force script re-evaluation for Safari
                if (!checks.leaflet) {
                    setTimeout(() => {
                        if (typeof L === 'undefined') {
                            log('Safari: Force reloading Leaflet...');
                            const script = document.createElement('script');
                            script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                            script.onload = () => {
                                log('Safari: Leaflet reloaded successfully');
                                setTimeout(initGame, 500);
                            };
                            document.head.appendChild(script);
                        }
                    }, 2000);
                }
            }
            
            return checks;
        }

        // Mobile-specific initialization with Safari fixes
        function initializeForMobile() {
            log('Initializing for mobile device...');
            
            // Safari specific fixes
            if (navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome')) {
                log('Applying Safari mobile optimizations...');
                
                // Prevent Safari zoom on input focus
                document.addEventListener('touchstart', function(e) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                        e.target.style.fontSize = '16px';
                    }
                });
                
                // Force hardware acceleration for Safari
                document.body.style.webkitTransform = 'translateZ(0)';
                document.body.style.webkitBackfaceVisibility = 'hidden';
            }
            
            if (!document.querySelector('meta[name="apple-mobile-web-app-capable"]')) {
                const meta = document.createElement('meta');
                meta.name = 'apple-mobile-web-app-capable';
                meta.content = 'yes';
                document.head.appendChild(meta);
            }
            
            // Prevent bounce scrolling
            document.body.style.overscroll = 'none';
            document.body.style.webkitOverflowScrolling = 'touch';
            
            const mapContainer = document.getElementById('map');
            if (mapContainer) {
                mapContainer.style.transform = 'translateZ(0)';
                mapContainer.style.webkitTransform = 'translateZ(0)';
                mapContainer.style.webkitBackfaceVisibility = 'hidden';
            }
            
            log('Mobile initialization complete');
        }

        // Mobile Game UI Functions
        function initMobileGameUI() {
            if (window.innerWidth > 768) return; // PC only
            
            log('Initializing mobile game UI...');
            
            // Hide desktop challenge section on mobile during game
            const challengeSection = document.getElementById('challenge-section');
            if (challengeSection) {
                challengeSection.style.display = 'none';
            }
        }

        function showMobileGameUI() {
            if (window.innerWidth > 768) return;
            
            log('Showing mobile game UI...');
            
            const overlay = document.getElementById('mobile-game-overlay');
            const body = document.body;
            
            if (overlay) {
                overlay.classList.add('active');
            }
            
            // Add game-playing class to body for CSS targeting
            body.classList.add('game-playing');
            
            updateMobileGameStats();
        }

        function hideMobileGameUI() {
            if (window.innerWidth > 768) return;
            
            const overlay = document.getElementById('mobile-game-overlay');
            const body = document.body;
            
            if (overlay) {
                overlay.classList.remove('active');
            }
            
            body.classList.remove('game-playing');
        }

        function updateMobileGameStats() {
            if (window.innerWidth > 768) return;
            
            // Update mobile stats display
            const mobileScore = document.getElementById('mobile-score');
            const mobileStreak = document.getElementById('mobile-streak');
            const mobileTimer = document.getElementById('mobile-timer');
            
            if (mobileScore) mobileScore.textContent = gameState.score;
            if (mobileStreak) mobileStreak.textContent = gameState.streak;
            if (mobileTimer) {
                mobileTimer.textContent = gameState.timer;
                
                // Update timer appearance
                mobileTimer.classList.remove('warning', 'danger');
                if (gameState.timer <= 5) {
                    mobileTimer.classList.add('danger');
                } else if (gameState.timer <= 10) {
                    mobileTimer.classList.add('warning');
                }
            }
        }

        function updateMobileQuestion(questionText, questionType) {
            if (window.innerWidth > 768) return;
            
            const mobileQuestionText = document.getElementById('mobile-question-text');
            const mobileQuestionType = document.getElementById('mobile-question-type');
            
            if (mobileQuestionText) {
                mobileQuestionText.textContent = questionText;
            }
            if (mobileQuestionType) {
                mobileQuestionType.textContent = questionType;
            }
        }

        function showMobileChoices(choices) {
            if (window.innerWidth > 768) return;
            
            const overlay = document.getElementById('mobile-choices-overlay');
            const grid = document.getElementById('mobile-choices-grid');
            
            if (!overlay || !grid) return;
            
            // Clear existing choices
            grid.innerHTML = '';
            
            // Create choice buttons
            choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'mobile-choice-btn';
                button.textContent = choice.name;
                button.onclick = () => handleMobileChoiceClick(choice, button);
                grid.appendChild(button);
            });
            
            overlay.classList.remove('hidden');
        }

        function hideMobileChoices() {
            if (window.innerWidth > 768) return;
            
            const overlay = document.getElementById('mobile-choices-overlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
        }

        function handleMobileChoiceClick(selectedChoice, button) {
            // Disable all buttons
            document.querySelectorAll('.mobile-choice-btn').forEach(btn => {
                btn.disabled = true;
                btn.style.pointerEvents = 'none';
            });
            
            // Handle the answer (reuse existing logic)
            handleReverseAnswer(selectedChoice, button);
        }

        function showMobileDistance(distance, accuracy) {
            if (window.innerWidth > 768) return;
            
            const overlay = document.getElementById('mobile-distance-overlay');
            const distanceEl = document.getElementById('mobile-distance');
            const accuracyEl = document.getElementById('mobile-accuracy');
            
            if (overlay && distanceEl && accuracyEl) {
                distanceEl.textContent = distance;
                accuracyEl.textContent = accuracy;
                overlay.classList.remove('hidden');
            }
        }

        function hideMobileDistance() {
            if (window.innerWidth > 768) return;
            
            const overlay = document.getElementById('mobile-distance-overlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
        }

        // Problem Editor Functions - 関数宣言で巻き上げを利用
        function addPointFromMap(lat, lng) {
            const advancedSettings = document.getElementById('advanced-settings');
            if (!advancedSettings || advancedSettings.classList.contains('hidden')) {
                return;
            }
            
            gameState.currentEditPoints.push({ lat, lng });
            updatePointsList();
            
            const marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'edit-point-marker',
                    html: '<div style="background: #2196F3; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                    iconSize: [12, 12]
                })
            }).addTo(gameState.facilityLayer);
            
            showInfo(`Point added: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
        }

        function updatePointsList() {
            const container = document.getElementById('current-points');
            
            if (gameState.currentEditPoints.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No points added yet</div>';
                return;
            }
            
            container.innerHTML = '';
            gameState.currentEditPoints.forEach((point, index) => {
                const pointDiv = document.createElement('div');
                pointDiv.className = 'point-item';
                pointDiv.innerHTML = `
                    <span class="point-coords">${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}</span>
                    <button class="point-remove" onclick="removePoint(${index})">Remove</button>
                `;
                container.appendChild(pointDiv);
            });
        }

        function removePoint(index) {
            gameState.currentEditPoints.splice(index, 1);
            updatePointsList();
            
            gameState.facilityLayer.clearLayers();
            gameState.currentEditPoints.forEach(point => {
                L.marker([point.lat, point.lng], {
                    icon: L.divIcon({
                        className: 'edit-point-marker',
                        html: '<div style="background: #2196F3; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                        iconSize: [12, 12]
                    })
                }).addTo(gameState.facilityLayer);
            });
        }

        function clearPoints() {
            gameState.currentEditPoints = [];
            updatePointsList();
            gameState.facilityLayer.clearLayers();
        }

        function saveProblem() {
            const name = document.getElementById('problem-name').value.trim();
            const type = document.getElementById('problem-type').value;
            const description = document.getElementById('problem-description').value.trim();
            const importance = parseInt(document.getElementById('problem-importance').value);
            
            if (!name) {
                showWarning('Please enter a problem name');
                return;
            }
            
            if (gameState.currentEditPoints.length === 0) {
                showWarning('Please add at least one point for this problem');
                return;
            }
            
            const problem = {
                name,
                type,
                description: description || `Custom ${type}`,
                importance,
                points: [gameState.currentEditPoints.slice()],
                isEnclosedArea: gameState.currentEditPoints.length > 3 && type === 'facility',
                source: 'custom',
                id: Date.now()
            };
            
            if (gameState.editingProblem) {
                const index = gameState.customProblems.findIndex(p => p.id === gameState.editingProblem.id);
                if (index !== -1) {
                    gameState.customProblems[index] = problem;
                    problem.id = gameState.editingProblem.id;
                }
                gameState.editingProblem = null;
                showSuccess('Problem updated successfully!');
            } else {
                gameState.customProblems.push(problem);
                showSuccess('Problem saved successfully!');
            }
            
            saveCustomProblems();
            updateCustomProblemsList();
            clearProblemEditor();
        }

        function clearProblemEditor() {
            document.getElementById('problem-name').value = '';
            document.getElementById('problem-description').value = '';
            document.getElementById('problem-importance').value = '70';
            updateImportanceDisplay();
            clearPoints();
        }

        function updateCustomProblemsList() {
            const container = document.getElementById('custom-problems');
            
            if (gameState.customProblems.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No custom problems yet</div>';
                return;
            }
            
            container.innerHTML = '';
            gameState.customProblems.forEach(problem => {
                const problemDiv = document.createElement('div');
                problemDiv.className = 'problem-item';
                problemDiv.innerHTML = `
                    <div>
                        <div class="problem-name">${problem.name}</div>
                        <div class="problem-info">${problem.type} - Importance: ${problem.importance}</div>
                    </div>
                    <div class="problem-actions">
                        <button class="btn-small btn-edit" onclick="editProblem(${problem.id})">Edit</button>
                        <button class="btn-small btn-delete" onclick="deleteProblem(${problem.id})">Delete</button>
                    </div>
                `;
                container.appendChild(problemDiv);
            });
        }

        function editProblem(problemId) {
            const problem = gameState.customProblems.find(p => p.id === problemId);
            if (!problem) return;
            
            gameState.editingProblem = problem;
            
            document.getElementById('problem-name').value = problem.name;
            document.getElementById('problem-type').value = problem.type;
            document.getElementById('problem-description').value = problem.description;
            document.getElementById('problem-importance').value = problem.importance;
            updateImportanceDisplay();
            
            gameState.currentEditPoints = problem.points[0].slice();
            updatePointsList();
            
            gameState.facilityLayer.clearLayers();
            gameState.currentEditPoints.forEach(point => {
                L.marker([point.lat, point.lng], {
                    icon: L.divIcon({
                        className: 'edit-point-marker',
                        html: '<div style="background: #2196F3; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                        iconSize: [12, 12]
                    })
                }).addTo(gameState.facilityLayer);
            });
            
            showInfo('Editing problem: ' + problem.name);
        }

        function deleteProblem(problemId) {
            if (confirm('Are you sure you want to delete this problem?')) {
                gameState.customProblems = gameState.customProblems.filter(p => p.id !== problemId);
                saveCustomProblems();
                updateCustomProblemsList();
                showInfo('Problem deleted');
            }
        }

        function saveCustomProblems() {
            try {
                const data = JSON.stringify(gameState.customProblems);
                window.localStorage?.setItem('customProblems', data);
            } catch (error) {
                console.warn('Could not save custom problems:', error);
            }
        }

        function loadCustomProblems() {
            try {
                const data = window.localStorage?.getItem('customProblems');
                if (data) {
                    gameState.customProblems = JSON.parse(data);
                    updateCustomProblemsList();
                }
            } catch (error) {
                console.warn('Could not load custom problems:', error);
                gameState.customProblems = [];
            }
        }

        // Check if Turf.js is loaded, if not load alternative or use fallback
        if (typeof turf === 'undefined') {
            console.warn('Turf.js not loaded, using fallback geometry functions');
            
            window.turf = {
                point: function(coords) {
                    return { geometry: { coordinates: coords, type: 'Point' } };
                },
                distance: function(from, to, options) {
                    const lat1 = from.geometry.coordinates[1];
                    const lon1 = from.geometry.coordinates[0];
                    const lat2 = to.geometry.coordinates[1];
                    const lon2 = to.geometry.coordinates[0];
                    
                    const R = 6371;
                    const dLat = (lat2 - lat1) * Math.PI / 180;
                    const dLon = (lon2 - lon1) * Math.PI / 180;
                    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                             Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                             Math.sin(dLon/2) * Math.sin(dLon/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    const distance = R * c;
                    
                    return options && options.units === 'meters' ? distance * 1000 : distance;
                },
                lineString: function(coords) {
                    return { geometry: { coordinates: coords, type: 'LineString' } };
                },
                nearestPointOnLine: function(line, point) {
                    const coords = line.geometry.coordinates;
                    let minDist = Infinity;
                    let nearest = coords[0];
                    
                    for (let i = 0; i < coords.length; i++) {
                        const dist = this.distance(
                            { geometry: { coordinates: coords[i] } },
                            point,
                            { units: 'meters' }
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = coords[i];
                        }
                    }
                    
                    return { geometry: { coordinates: nearest } };
                },
                midpoint: function(point1, point2) {
                    const lat1 = point1.geometry.coordinates[1];
                    const lon1 = point1.geometry.coordinates[0];
                    const lat2 = point2.geometry.coordinates[1];
                    const lon2 = point2.geometry.coordinates[0];
                    
                    return {
                        geometry: {
                            coordinates: [(lon1 + lon2) / 2, (lat1 + lat2) / 2]
                        }
                    };
                }
            };
        }

        // Game state
        let gameState = {
            isPlaying: false,
            currentMode: 'street',
            difficulty: 'user-created-tokyo',
            score: 0,
            streak: 0,
            totalQuestions: 0,
            currentQuestion: null,
            timer: 30,
            timerInterval: null,
            map: null,
            gameArea: null,
            userMarker: null,
            correctMarker: null,
            streetLayer: null,
            facilityLayer: null,
            center: { lat: 35.6762, lng: 139.6503 },
            range: 5,
            showLabels: true,
            baseLayers: {},
            streetData: null,
            isLoadingData: false,
            isMapInitialized: false,
            settingsVisible: true,
            customProblems: [],
            editorMode: false,
            currentEditPoints: [],
            editingProblem: null,
            askedQuestions: [],
            currentLocation: null,
            loadingStrategy: 'immediate',
            backgroundLoading: false,
            cacheEnabled: true,
            dataQuality: 'partial',
            initRetryCount: 0,
            isMobileDevice: false,
            networkStatus: 'unknown',
            githubKmlLoaded: false,
            githubKmlData: [],
            autoLoadComplete: false
        };

        // GitHub KML Repository Configuration
        const GITHUB_KML_CONFIG = {
            owner: 'daytimegufo',
            repo: 'Street_Sensei',
            branch: 'main',
            path: 'kml_files',
            baseUrl: 'https://raw.githubusercontent.com/daytimegufo/Street_Sensei/main/kml_files/',
            availableRoads: [
                { name: '六本木通り', file: 'roppongi_dori.kml' },
                { name: '靖国通り', file: 'yasukuni_dori.kml' },
                { name: '明治通り', file: 'meiji_dori.kml' },
                { name: '青山通り', file: 'aoyama_dori.kml' },
                { name: '外苑東通り', file: 'gaienhigashi_dori.kml' },
                { name: '表参道', file: 'omotesando.kml' },
                { name: '竹下通り', file: 'takeshita_dori.kml' },
                { name: '中央通り', file: 'chuo_dori.kml' },
                { name: '昭和通り', file: 'showa_dori.kml' },
                { name: '新宿通り', file: 'shinjuku_dori.kml' },
                { name: '甲州街道', file: 'koshu_kaido.kml' },
                { name: '青梅街道', file: 'ome_kaido.kml' },
                { name: '環七通り', file: 'kanana_dori.kml' },
                { name: '環八通り', file: 'kanhachi_dori.kml' },
                { name: '山手通り', file: 'yamate_dori.kml' }
            ]
        };

        // Auto-load GitHub KML data during initialization
        async function autoLoadGithubKml(maxRoads = 25) {
            if (gameState.githubKmlLoaded) {
                log('GitHub KML data already loaded');
                return true;
            }

            try {
                log(`🔄 Starting auto-load of GitHub KML data (max: ${maxRoads} roads)...`);
                
                const roadsToLoad = GITHUB_KML_CONFIG.availableRoads.slice(0, maxRoads);
                const loadedRoads = [];
                let successCount = 0;

                for (let i = 0; i < roadsToLoad.length; i++) {
                    const road = roadsToLoad[i];
                    
                    try {
                        const url = GITHUB_KML_CONFIG.baseUrl + road.file;
                        log(`📥 Loading ${road.name} (${i + 1}/${roadsToLoad.length})...`);
                        
                        const response = await fetch(url);
                        
                        if (response.ok) {
                            const kmlContent = await response.text();
                            const parsedRoad = await parseGithubKmlContent(kmlContent, road.name);
                            
                            if (parsedRoad) {
                                loadedRoads.push(parsedRoad);
                                successCount++;
                                log(`✅ ${road.name} loaded successfully`);
                            }
                        } else {
                            log(`⚠️ Failed to load ${road.name}: HTTP ${response.status}`);
                        }
                    } catch (error) {
                        log(`❌ Error loading ${road.name}: ${error.message}`);
                    }
                    
                    // Delay between requests to be respectful to GitHub
                    if (i < roadsToLoad.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                if (loadedRoads.length > 0) {
                    gameState.githubKmlData = loadedRoads;
                    gameState.githubKmlLoaded = true;
                    
                    // Add to street data if user-created mode is selected
                    const difficultySelect = document.getElementById('difficulty');
                    if (difficultySelect && difficultySelect.value === 'user-created-tokyo') {
                        gameState.streetData = [...(gameState.streetData || []), ...loadedRoads];
                    }
                    
                    showSuccess(`🎉 GitHub KML auto-load complete! ${successCount}/${roadsToLoad.length} roads loaded from daytimegufo/Street_Sensei`);
                    updateGithubKmlStatus();
                    log(`🏁 Auto-load complete: ${successCount} roads from GitHub KML repository`);
                    return true;
                } else {
                    log('⚠️ No roads were successfully loaded from GitHub');
                    return false;
                }

            } catch (error) {
                log(`❌ GitHub KML auto-load error: ${error.message}`);
                return false;
            }
        }

        // Parse GitHub KML content
        async function parseGithubKmlContent(kmlContent, roadName) {
            try {
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlContent, 'text/xml');
                
                const placemarks = kmlDoc.getElementsByTagName('Placemark');
                
                for (let i = 0; i < placemarks.length; i++) {
                    const placemark = placemarks[i];
                    const name = placemark.getElementsByTagName('name')[0]?.textContent?.trim();
                    const description = placemark.getElementsByTagName('description')[0]?.textContent?.trim() || '';
                    
                    if (!name) continue;
                    
                    const lineString = placemark.getElementsByTagName('LineString')[0];
                    if (lineString) {
                        const coordsText = lineString.getElementsByTagName('coordinates')[0]?.textContent;
                        if (coordsText) {
                            const coordinates = parseCoordinateString(coordsText);
                            if (coordinates.length > 0) {
                                return {
                                    name: roadName || name,
                                    points: [coordinates],
                                    importance: 85, // High importance for curated roads
                                    description: description || `GitHub道路データ: ${roadName}`,
                                    source: 'github-kml',
                                    isComplete: true,
                                    segmentLength: calculateSegmentLength(coordinates),
                                    githubOriginal: true
                                };
                            }
                        }
                    }
                }
                
                return null;
            } catch (error) {
                log(`Error parsing GitHub KML for ${roadName}: ${error.message}`);
                return null;
            }
        }

        // Update GitHub KML status display
        function updateGithubKmlStatus() {
            const statusDiv = document.getElementById('user-kml-status');
            if (statusDiv) {
                if (gameState.githubKmlLoaded && gameState.githubKmlData.length > 0) {
                    statusDiv.innerHTML = `
                        ✅ GitHub KML データ読み込み完了！<br>
                        <span style="color: #4CAF50;">${gameState.githubKmlData.length}本の道路が利用可能</span><br>
                        <small style="color: #aaa;">daytimegufo/Street_Sensei より自動読み込み</small>
                    `;
                    statusDiv.style.background = '#2d5a2d';
                } else {
                    statusDiv.innerHTML = `
                        💡 GitHub: daytimegufo/Street_Sensei から149本の東京都通称道路名を選択可能<br>
                        <small style="color: #aaa;">自動読み込み中...</small>
                    `;
                }
            }
        }

        // Update KML selection options with loaded roads
        function updateKmlSelectionOptions() {
            const kmlSelection = document.getElementById('kml-selection');
            if (!kmlSelection) return;
            
            // Clear existing options except "all"
            while (kmlSelection.children.length > 1) {
                kmlSelection.removeChild(kmlSelection.lastChild);
            }
            
            // Update "all" option with actual count
            const allOption = kmlSelection.children[0];
            if (allOption && gameState.githubKmlLoaded) {
                allOption.textContent = `📍 全ての道路（GitHub: ${gameState.githubKmlData.length}本）`;
            }
            
            // Add loaded roads to selection
            if (gameState.githubKmlLoaded && gameState.githubKmlData.length > 0) {
                gameState.githubKmlData.forEach(road => {
                    const option = document.createElement('option');
                    option.value = road.name;
                    option.textContent = road.name;
                    kmlSelection.appendChild(option);
                });
                
                log(`Updated KML selection with ${gameState.githubKmlData.length} roads`);
            }
        }

        // Load selected GitHub roads
        async function loadSelectedGithubRoads() {
            try {
                const kmlSelection = document.getElementById('kml-selection');
                if (!kmlSelection) return;
                
                const selectedValues = Array.from(kmlSelection.selectedOptions).map(option => option.value);
                
                if (selectedValues.length === 0) {
                    showWarning('道路を選択してください');
                    return;
                }
                
                log(`Loading ${selectedValues.length} selected GitHub roads...`);
                
                const loadBtn = document.getElementById('load-user-kml');
                if (loadBtn) {
                    loadBtn.innerHTML = '<span class="loading"></span>Loading...';
                    loadBtn.disabled = true;
                }
                
                let loadedRoads = [];
                
                if (selectedValues.includes('all')) {
                    // Load all available roads
                    if (gameState.githubKmlLoaded) {
                        loadedRoads = gameState.githubKmlData;
                    } else {
                        const success = await autoLoadGithubKml(GITHUB_KML_CONFIG.availableRoads.length);
                        if (success) {
                            loadedRoads = gameState.githubKmlData;
                        }
                    }
                } else {
                    // Load specific selected roads
                    const roadsToLoad = GITHUB_KML_CONFIG.availableRoads.filter(road => 
                        selectedValues.includes(road.name)
                    );
                    
                    for (const road of roadsToLoad) {
                        try {
                            const url = GITHUB_KML_CONFIG.baseUrl + road.file;
                            const response = await fetch(url);
                            
                            if (response.ok) {
                                const kmlContent = await response.text();
                                const parsedRoad = await parseGithubKmlContent(kmlContent, road.name);
                                if (parsedRoad) {
                                    loadedRoads.push(parsedRoad);
                                }
                            }
                        } catch (error) {
                            log(`Error loading ${road.name}: ${error.message}`);
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                if (loadedRoads.length > 0) {
                    gameState.streetData = loadedRoads;
                    gameState.githubKmlData = loadedRoads;
                    gameState.githubKmlLoaded = true;
                    
                    showSuccess(`✅ ${loadedRoads.length}本の道路データを読み込み完了！`);
                    updateDataStatus();
                    updateGithubKmlStatus();
                } else {
                    showWarning('道路データの読み込みに失敗しました');
                }
                
            } catch (error) {
                log('Error loading selected GitHub roads: ' + error.message);
                showError('道路データの読み込み中にエラーが発生しました');
            } finally {
                const loadBtn = document.getElementById('load-user-kml');
                if (loadBtn) {
                    loadBtn.textContent = '📥 選択した道路データを読み込み';
                    loadBtn.disabled = false;
                }
            }
        }

        // Enhanced sample data with actual coordinates
        const facilityQuestions = [
            {
                name: "東京タワー",
                points: [[{ lat: 35.6586, lng: 139.7454 }]],
                isEnclosedArea: false,
                facilityType: "tower",
                category: "tourism",
                importance: 80,
                description: "333mの赤い電波塔",
                source: "default"
            },
            {
                name: "東京駅",
                points: [[{ lat: 35.6812, lng: 139.7671 }]],
                isEnclosedArea: false,
                facilityType: "station",
                category: "transport",
                importance: 90,
                description: "東京の玄関口となる中央駅",
                source: "default"
            },
            {
                name: "渋谷スクランブル交差点",
                points: [[{ lat: 35.6598, lng: 139.7006 }]],
                isEnclosedArea: false,
                facilityType: "intersection",
                category: "landmark",
                importance: 85,
                description: "世界で最も有名な歩行者用交差点",
                source: "default"
            },
            {
                name: "皇居",
                points: [[
                    { lat: 35.6852, lng: 139.7528 },
                    { lat: 35.6820, lng: 139.7580 },
                    { lat: 35.6795, lng: 139.7550 },
                    { lat: 35.6830, lng: 139.7500 },
                    { lat: 35.6852, lng: 139.7528 }
                ]],
                isEnclosedArea: true,
                facilityType: "palace",
                category: "landmark",
                importance: 95,
                description: "日本の皇室の宮殿",
                source: "default"
            }
        ];

        const intersectionQuestions = [
            {
                name: "渋谷スクランブル交差点",
                points: [[{ lat: 35.6598, lng: 139.7006 }]],
                importance: 90,
                description: "世界で最も混雑する歩行者用交差点",
                source: "default"
            },
            {
                name: "銀座四丁目交差点",
                points: [[{ lat: 35.6717, lng: 139.7635 }]],
                importance: 80,
                description: "銀座の中心となる大きな交差点",
                source: "default"
            },
            {
                name: "新宿東口交差点",
                points: [[{ lat: 35.6896, lng: 139.7006 }]],
                importance: 75,
                description: "新宿駅東口前の主要交差点",
                source: "default"
            }
        ];

        // Regional bbox configurations for full road network extraction
        const REGIONAL_CONFIGS = {
            'south-kanto': {
                name: '南関東',
                bbox: { south: 34.8, west: 138.8, north: 36.3, east: 140.9 },
                majorRoads: [
                    '環状七号線', '環状八号線', '甲州街道', '青梅街道', '目白通り', '明治通り',
                    '昭和通り', '中央通り', '外苑東通り', '外苑西通り', '靖国通り', '新宿通り',
                    '表参道', '竹下通り', '六本木通り', '麻布通り', '桜田通り', '第一京浜',
                    '第二京浜', '産業道路', '多摩川通り', '世田谷通り', '駒沢通り', '玉川通り',
                    '国道1号', '国道14号', '国道15号', '国道16号', '国道20号', '国道246号',
                    '国道357号', '国道409号', '都道418号', '山手通り', '井の頭通り',
                    '五日市街道', '小金井街道', '中野通り', '早稲田通り', '春日通り',
                    '不忍通り', '言問通り', '水戸街道', '蔵前橋通り', '清洲橋通り'
                ]
            },
            'tokyo-center': {
                name: '東京都心',
                bbox: { south: 35.6, west: 139.6, north: 35.75, east: 139.85 },
                majorRoads: [
                    '環状七号線', '環状八号線', '山手通り', '明治通り', '昭和通り',
                    '中央通り', '外苑東通り', '靖国通り', '新宿通り', '表参道',
                    '六本木通り', '桜田通り', '第一京浜', '国道1号', '国道14号',
                    '国道15号', '国道20号', '国道246号'
                ]
            }
        };

        // Optimized loading strategy
        const LOADING_STRATEGIES = {
            'immediate': {
                name: '即座開始 (Fast Start)',
                description: '基本的な道路のみ事前読み込み、他は必要時に取得',
                preloadCount: 10,
                batchSize: 3,
                delay: 1000
            },
            'balanced': {
                name: 'バランス型 (Balanced)',
                description: '重要な道路を段階的に読み込み',
                preloadCount: 20,
                batchSize: 4,
                delay: 1500
            },
            'complete': {
                name: '完全読み込み (Complete)',
                description: '全道路を事前読み込み（時間がかかります）',
                preloadCount: -1,
                batchSize: 5,
                delay: 2000
            }
        };

        // Cache system for loaded road data
        const ROAD_CACHE = {
            data: new Map(),
            
            save: function(regionKey, strategyKey, roadData) {
                const cacheKey = `${regionKey}-${strategyKey}`;
                this.data.set(cacheKey, {
                    roads: roadData,
                    timestamp: Date.now(),
                    version: '1.0'
                });
                
                try {
                    const compressed = JSON.stringify({
                        roads: roadData.slice(0, 50),
                        timestamp: Date.now()
                    });
                    localStorage.setItem(`roadCache_${cacheKey}`, compressed);
                } catch (error) {
                    console.warn('Could not save to localStorage:', error);
                }
            },
            
            load: function(regionKey, strategyKey) {
                const cacheKey = `${regionKey}-${strategyKey}`;
                
                if (this.data.has(cacheKey)) {
                    const cached = this.data.get(cacheKey);
                    const age = Date.now() - cached.timestamp;
                    if (age < 24 * 60 * 60 * 1000) {
                        return cached.roads;
                    }
                }
                
                try {
                    const stored = localStorage.getItem(`roadCache_${cacheKey}`);
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        const age = Date.now() - parsed.timestamp;
                        if (age < 24 * 60 * 60 * 1000) {
                            this.data.set(cacheKey, {
                                roads: parsed.roads,
                                timestamp: parsed.timestamp,
                                version: '1.0'
                            });
                            return parsed.roads;
                        }
                    }
                } catch (error) {
                    console.warn('Could not load from localStorage:', error);
                }
                
                return null;
            },
            
            exists: function(regionKey, strategyKey) {
                return this.load(regionKey, strategyKey) !== null;
            }
        };

        const streetQuestions = [
            {
                name: "表参道",
                points: [[
                    { lat: 35.6654, lng: 139.7134 },
                    { lat: 35.6670, lng: 139.7110 },
                    { lat: 35.6690, lng: 139.7085 },
                    { lat: 35.6699, lng: 139.7079 }
                ]],
                importance: 85,
                description: "明治神宮への参道として作られた並木道",
                source: "default"
            },
            {
                name: "竹下通り",
                points: [[
                    { lat: 35.6702, lng: 139.7063 },
                    { lat: 35.6700, lng: 139.7060 },
                    { lat: 35.6698, lng: 139.7057 }
                ]],
                importance: 75,
                description: "原宿の若者文化の中心地",
                source: "default"
            },
            {
                name: "中央通り",
                points: [[
                    { lat: 35.6717, lng: 139.7635 },
                    { lat: 35.6720, lng: 139.7640 },
                    { lat: 35.6725, lng: 139.7645 },
                    { lat: 35.6730, lng: 139.7650 }
                ]],
                importance: 80,
                description: "銀座のメインストリート",
                source: "default"
            },
            {
                name: "青山通り",
                points: [[
                    { lat: 35.6650, lng: 139.7200 },
                    { lat: 35.6670, lng: 139.7180 },
                    { lat: 35.6690, lng: 139.7160 },
                    { lat: 35.6710, lng: 139.7140 }
                ]],
                importance: 70,
                description: "青山エリアを通る主要道路",
                source: "default"
            }
        ];

        // Sample Yamate-dori KML data
        const yamateKmlData = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
    <Document>
        <Placemark>
            <name>山手通り</name>
            <description>読み仮名: やまてどおり
起点: 品川区東品川一丁目（新東海橋） →
終点: 板橋区氷川町（仲宿）</description>
            <LineString>
                <coordinates>139.686036,35.713522,0.0 139.686069,35.713592,0.0 139.686283,35.714042,0.0 139.686876,35.715233,0.0 139.687218,35.716003,0.0 139.687307,35.716187,0.0</coordinates>
            </LineString>
        </Placemark>
    </Document>
</kml>`;

        // Current regional configuration and loading strategy
        let currentRegionalConfig = REGIONAL_CONFIGS['south-kanto'];
        let currentLoadingStrategy = LOADING_STRATEGIES['immediate'];

        // Initialize the game
        function initGame() {
            try {
                log('Initializing enhanced game...');
                
                if (typeof L === 'undefined') {
                    log('Leaflet not loaded, waiting...');
                    setTimeout(initGame, 500);
                    return;
                }
                
                initMap();
                bindEvents();
                updateRangeDisplay();
                updateImportanceDisplay();
                loadCustomProblems();
                
                // Auto-load GitHub KML data in the background
                if (!gameState.autoLoadComplete) {
                    gameState.autoLoadComplete = true;
                    setTimeout(() => {
                        autoLoadGithubKml(25).then(success => {
                            if (success) {
                                log('🎉 GitHub KML auto-load completed successfully');
                                
                                // Update KML selection dropdown with loaded roads
                                updateKmlSelectionOptions();
                            } else {
                                log('⚠️ GitHub KML auto-load completed with some failures');
                            }
                        }).catch(error => {
                            log('❌ GitHub KML auto-load failed: ' + error.message);
                        });
                    }, 2000); // Start auto-loading after 2 seconds
                }
                
                if (navigator.geolocation && (window.location.protocol === 'https:' || window.location.hostname === 'localhost')) {
                    log('Geolocation available, attempting to get current location...');
                    setTimeout(getCurrentLocation, 1000);
                } else {
                    if (gameState.map && currentRegionalConfig) {
                        const bbox = currentRegionalConfig.bbox;
                        const centerLat = (bbox.north + bbox.south) / 2;
                        const centerLng = (bbox.east + bbox.west) / 2;
                        gameState.center = { lat: centerLat, lng: centerLng };
                        gameState.map.setView([centerLat, centerLng], 9);
                        updateGameArea();
                    }
                }
                
                log('Enhanced game initialized successfully');
            } catch (error) {
                log('Error initializing game: ' + error.message);
                console.error('Initialization error:', error);
                
                setTimeout(() => {
                    log('Retrying game initialization...');
                    initGame();
                }, 2000);
            }
        }

        function initMap() {
            try {
                log('Creating map...');
                
                const libCheck = checkLibraryLoading();
                if (!libCheck.leaflet) {
                    log('Leaflet not loaded yet, retrying...');
                    setTimeout(initMap, 1000);
                    return;
                }
                
                const mapContainer = document.getElementById('map');
                if (!mapContainer) {
                    log('Map container not found, retrying...');
                    setTimeout(initMap, 100);
                    return;
                }
                
                if (mapContainer._leaflet_id) {
                    log('Removing existing map...');
                    if (gameState.map) {
                        gameState.map.remove();
                        gameState.map = null;
                    }
                }
                
                if (window.innerWidth <= 768) {
                    initializeForMobile();
                }
                
                log('Initializing new map...');
                gameState.map = L.map('map', {
                    zoomControl: false,
                    center: [gameState.center.lat, gameState.center.lng],
                    zoom: 12,
                    tap: true,
                    tapTolerance: 15,
                    touchZoom: true,
                    bounceAtZoomLimits: false,
                    preferCanvas: true,
                    maxZoom: 18,
                    minZoom: 8,
                    zoomSnap: 0.5,
                    zoomDelta: 0.5,
                    wheelPxPerZoomLevel: 30
                });
                
                log('Map object created, adding tiles...');
                
                const tileServers = [
                    {
                        url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                        attribution: '© OpenStreetMap contributors',
                        name: 'OpenStreetMap'
                    },
                    {
                        url: 'https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
                        attribution: '© OpenStreetMap contributors, © CARTO',
                        subdomains: ['a', 'b', 'c', 'd'],
                        name: 'CartoDB Light'
                    },
                    {
                        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
                        attribution: '© Esri',
                        name: 'ESRI'
                    }
                ];
                
                let tileLayerLoaded = false;
                let currentTileIndex = 0;
                
                const tryLoadTileLayer = (withLabels = true) => {
                    if (currentTileIndex >= tileServers.length) {
                        log('All tile servers failed, using basic fallback');
                        document.getElementById('map').style.background = '#e0e0e0';
                        gameState.isMapInitialized = true;
                        return;
                    }
                    
                    const server = tileServers[currentTileIndex];
                    log(`Trying tile server: ${server.name} (${currentTileIndex + 1}/${tileServers.length})`);
                    
                    const tileLayer = L.tileLayer(server.url, {
                        attribution: server.attribution,
                        maxZoom: 19,
                        subdomains: server.subdomains || [],
                        errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                        timeout: 8000,
                        detectRetina: true,
                        updateWhenIdle: true,
                        updateWhenZooming: false,
                        keepBuffer: 2
                    });
                    
                    tileLayer.on('loading', function() {
                        log(`Loading tiles from ${server.name}...`);
                    });
                    
                    tileLayer.on('load', function() {
                        if (!tileLayerLoaded) {
                            tileLayerLoaded = true;
                            log(`Tiles loaded successfully from ${server.name}`);
                            
                            if (withLabels) {
                                gameState.baseLayers.withLabels = tileLayer;
                                if (server.name === 'CartoDB Light') {
                                    gameState.baseLayers.withoutLabels = L.tileLayer(
                                        'https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}.png',
                                        {
                                            attribution: '© OpenStreetMap contributors, © CARTO',
                                            subdomains: ['a', 'b', 'c', 'd'],
                                            maxZoom: 19
                                        }
                                    );
                                } else {
                                    gameState.baseLayers.withoutLabels = tileLayer;
                                }
                            }
                            
                            setTimeout(() => {
                                const debugInfo = document.getElementById('debug-info');
                                if (debugInfo) {
                                    debugInfo.style.display = 'none';
                                }
                            }, 2000);
                        }
                    });
                    
                    tileLayer.on('tileerror', function(e) {
                        log(`Tile error from ${server.name}: ${e.error || 'Unknown error'}`);
                        
                        if (!tileLayerLoaded) {
                            gameState.map.removeLayer(tileLayer);
                            currentTileIndex++;
                            setTimeout(() => tryLoadTileLayer(withLabels), 1000);
                        }
                    });
                    
                    setTimeout(() => {
                        if (!tileLayerLoaded) {
                            log(`Timeout for ${server.name}, trying next server...`);
                            gameState.map.removeLayer(tileLayer);
                            currentTileIndex++;
                            tryLoadTileLayer(withLabels);
                        }
                    }, 10000);
                    
                    tileLayer.addTo(gameState.map);
                };
                
                tryLoadTileLayer(true);
                
                gameState.streetLayer = L.layerGroup().addTo(gameState.map);
                gameState.facilityLayer = L.layerGroup().addTo(gameState.map);

                updateGameArea();
                
                gameState.isMapInitialized = true;
                log('Map initialized successfully');
                
                gameState.map.on('click', function(e) {
                    log('Map click detected at: ' + e.latlng.lat.toFixed(4) + ', ' + e.latlng.lng.toFixed(4));
                    handleMapClick(e);
                });
                
                gameState.map.whenReady(function() {
                    log('Map is ready for interaction');
                    setTimeout(() => {
                        gameState.map.invalidateSize();
                        log('Map size invalidated and ready');
                    }, 500);
                });
                
                gameState.map.on('moveend', function() {
                    log('Map moved to: ' + gameState.map.getCenter().lat.toFixed(4) + ', ' + gameState.map.getCenter().lng.toFixed(4));
                });
                
                if (window.innerWidth <= 768) {
                    gameState.map.on('zoomstart', function() {
                        log('Mobile zoom started');
                    });
                    
                    gameState.map.on('zoomend', function() {
                        log('Mobile zoom ended at level: ' + gameState.map.getZoom());
                    });
                }
                
            } catch (error) {
                log('Error creating map: ' + error.message);
                console.error('Map initialization error:', error);
                
                setTimeout(() => {
                    log('Retrying map initialization...');
                    gameState.isMapInitialized = false;
                    initMap();
                }, 3000);
            }
        }

        function updateGameArea() {
            try {
                if (gameState.gameArea) {
                    gameState.map.removeLayer(gameState.gameArea);
                }
                
                gameState.gameArea = L.circle([gameState.center.lat, gameState.center.lng], {
                    radius: gameState.range * 1000,
                    fillColor: '#4CAF50',
                    fillOpacity: 0.1,
                    color: '#4CAF50',
                    weight: 2
                }).addTo(gameState.map);
                
                log('Game area updated');
            } catch (error) {
                log('Error updating game area: ' + error.message);
            }
        }

        function bindEvents() {
            try {
                log('Binding events...');
                
                const menuToggle = document.getElementById('menu-toggle');
                const sidebar = document.getElementById('sidebar');
                if (menuToggle && sidebar) {
                    menuToggle.addEventListener('click', () => {
                        sidebar.classList.toggle('open');
                    });
                }

                document.querySelectorAll('.mode-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        log('Mode tab clicked: ' + e.target.dataset.mode);
                        document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        gameState.currentMode = e.target.dataset.mode;
                    });
                });

                const rangeSlider = document.getElementById('range');
                if (rangeSlider) {
                    rangeSlider.addEventListener('input', (e) => {
                        gameState.range = parseInt(e.target.value);
                        updateRangeDisplay();
                        updateGameArea();
                    });
                }

                const importanceSlider = document.getElementById('problem-importance');
                if (importanceSlider) {
                    importanceSlider.addEventListener('input', updateImportanceDisplay);
                }

                const difficultySelect = document.getElementById('difficulty');
                if (difficultySelect) {
                    difficultySelect.addEventListener('change', (e) => {
                        gameState.difficulty = e.target.value;
                        log('Difficulty changed to: ' + gameState.difficulty);
                        
                        // Show/hide user-created options
                        const userCreatedOptions = document.getElementById('user-created-options');
                        if (userCreatedOptions) {
                            if (e.target.value === 'user-created-tokyo') {
                                userCreatedOptions.style.display = 'block';
                                if (gameState.githubKmlLoaded) {
                                    gameState.streetData = gameState.githubKmlData;
                                    updateDataStatus();
                                }
                            } else {
                                userCreatedOptions.style.display = 'none';
                            }
                        }
                    });
                }

                const loadUserKmlBtn = document.getElementById('load-user-kml');
                if (loadUserKmlBtn) {
                    loadUserKmlBtn.addEventListener('click', () => {
                        loadSelectedGithubRoads();
                    });
                }

                const startBtn = document.getElementById('start-game');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        log('Start game clicked');
                        startGame();
                    });
                }

                const updateLocationBtn = document.getElementById('update-location');
                if (updateLocationBtn) {
                    updateLocationBtn.addEventListener('click', () => {
                        log('Update location clicked');
                        updateLocation();
                    });
                }

                const getCurrentLocationBtn = document.getElementById('get-current-location');
                if (getCurrentLocationBtn) {
                    getCurrentLocationBtn.addEventListener('click', () => {
                        log('Get current location clicked');
                        getCurrentLocation();
                    });
                }

                const locationInput = document.getElementById('location');
                if (locationInput) {
                    locationInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            updateLocation();
                        }
                    });
                }

                const loadDataBtn = document.getElementById('load-street-data');
                if (loadDataBtn) {
                    loadDataBtn.addEventListener('click', () => {
                        log('Load regional roads clicked');
                        const regionSelect = document.getElementById('region-select');
                        const strategySelect = document.getElementById('loading-strategy');
                        
                        const selectedRegion = regionSelect ? regionSelect.value : 'south-kanto';
                        const selectedStrategy = strategySelect ? strategySelect.value : 'immediate';
                        
                        loadRegionalRoadsOptimized(selectedRegion, selectedStrategy);
                    });
                }

                const regionSelect = document.getElementById('region-select');
                if (regionSelect) {
                    regionSelect.addEventListener('change', (e) => {
                        const selectedRegion = e.target.value;
                        log('Region changed to: ' + selectedRegion);
                        currentRegionalConfig = REGIONAL_CONFIGS[selectedRegion];
                        
                        if (gameState.map && currentRegionalConfig) {
                            const bbox = currentRegionalConfig.bbox;
                            const centerLat = (bbox.north + bbox.south) / 2;
                            const centerLng = (bbox.east + bbox.west) / 2;
                            gameState.center = { lat: centerLat, lng: centerLng };
                            gameState.map.setView([centerLat, centerLng], 9);
                            updateGameArea();
                        }
                    });
                }

                const strategySelect = document.getElementById('loading-strategy');
                if (strategySelect) {
                    strategySelect.addEventListener('change', (e) => {
                        const selectedStrategy = e.target.value;
                        currentLoadingStrategy = LOADING_STRATEGIES[selectedStrategy];
                        log('Loading strategy changed to: ' + currentLoadingStrategy.name);
                        
                        const description = strategySelect.nextElementSibling;
                        if (description) {
                            description.textContent = currentLoadingStrategy.description;
                        }
                    });
                }

                const toggleSettingsBtn = document.getElementById('toggle-settings');
                if (toggleSettingsBtn) {
                    toggleSettingsBtn.addEventListener('click', () => {
                        toggleSettings();
                    });
                }

                const nextBtn = document.getElementById('next-question');
                if (nextBtn) {
                    nextBtn.addEventListener('click', () => {
                        log('Next question clicked');
                        nextQuestion();
                    });
                }

                const showAnswerBtn = document.getElementById('show-answer');
                if (showAnswerBtn) {
                    showAnswerBtn.addEventListener('click', () => {
                        log('Show answer clicked');
                        showAnswer();
                    });
                }

                const endBtn = document.getElementById('end-game');
                if (endBtn) {
                    endBtn.addEventListener('click', () => {
                        log('End game clicked');
                        endGame();
                    });
                }

                const saveBtn = document.getElementById('save-problem');
                if (saveBtn) {
                    saveBtn.addEventListener('click', saveProblem);
                }

                const cancelBtn = document.getElementById('cancel-edit');
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        clearProblemEditor();
                        gameState.editingProblem = null;
                        showInfo('Edit cancelled');
                    });
                }

                const clearPointsBtn = document.getElementById('clear-points');
                if (clearPointsBtn) {
                    clearPointsBtn.addEventListener('click', clearPoints);
                }

                const kmlFileInput = document.getElementById('kml-file');
                if (kmlFileInput) {
                    kmlFileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            handleKmlFile(file);
                        }
                    });
                }

                const loadSampleBtn = document.getElementById('load-sample-kml');
                if (loadSampleBtn) {
                    loadSampleBtn.addEventListener('click', loadSampleKml);
                }

                const zoomInBtn = document.getElementById('zoom-in');
                if (zoomInBtn) {
                    zoomInBtn.addEventListener('click', () => {
                        if (gameState.map) {
                            gameState.map.zoomIn();
                        }
                    });
                }

                const zoomOutBtn = document.getElementById('zoom-out');
                if (zoomOutBtn) {
                    zoomOutBtn.addEventListener('click', () => {
                        if (gameState.map) {
                            gameState.map.zoomOut();
                        }
                    });
                }

                const toggleLabelsBtn = document.getElementById('toggle-labels');
                if (toggleLabelsBtn) {
                    toggleLabelsBtn.addEventListener('click', () => {
                        toggleLabels();
                    });
                }

                const mobileMenuBtn = document.getElementById('mobile-menu');
                if (mobileMenuBtn) {
                    mobileMenuBtn.addEventListener('click', () => {
                        sidebar.classList.toggle('open');
                    });
                }

                const mobileNextBtn = document.getElementById('mobile-next');
                if (mobileNextBtn) {
                    mobileNextBtn.addEventListener('click', () => {
                        nextQuestion();
                    });
                }

                const mobileAnswerBtn = document.getElementById('mobile-answer');
                if (mobileAnswerBtn) {
                    mobileAnswerBtn.addEventListener('click', () => {
                        showAnswer();
                    });
                }

                const mobileEndBtn = document.getElementById('mobile-end');
                if (mobileEndBtn) {
                    mobileEndBtn.addEventListener('click', () => {
                        endGame();
                    });
                }

                document.addEventListener('click', (e) => {
                    if (window.innerWidth <= 768) {
                        const sidebar = document.getElementById('sidebar');
                        const menuToggle = document.getElementById('menu-toggle');
                        const mobileMenu = document.getElementById('mobile-menu');
                        
                        if (!sidebar.contains(e.target) && 
                            e.target !== menuToggle && 
                            e.target !== mobileMenu) {
                            sidebar.classList.remove('open');
                        }
                    }
                });

                log('Events bound successfully');
            } catch (error) {
                log('Error binding events: ' + error.message);
                console.error('Event binding error:', error);
            }
        }

        // Location Services
        function getCurrentLocation() {
            const status = document.getElementById('location-status');
            if (status) {
                status.className = 'location-status pending';
                status.innerHTML = '<span class="loading"></span>Getting current location...';
                status.classList.remove('hidden');
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000
            };

            navigator.geolocation.getCurrentPosition(
                function(position) {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    
                    gameState.currentLocation = { lat, lng };
                    gameState.center = { lat, lng };
                    
                    if (gameState.map) {
                        gameState.map.setView([lat, lng], 14);
                        updateGameArea();
                    }
                    
                    const locationInput = document.getElementById('location');
                    if (locationInput) {
                        locationInput.value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    }
                    
                    if (status) {
                        status.className = 'location-status success';
                        status.textContent = '✅ Location updated to current position';
                    }
                    
                    setTimeout(() => {
                        const regionSelect = document.getElementById('region-select');
                        const strategySelect = document.getElementById('loading-strategy');
                        
                        const selectedRegion = regionSelect ? regionSelect.value : 'south-kanto';
                        const selectedStrategy = strategySelect ? strategySelect.value : 'immediate';
                        
                        loadRegionalRoadsOptimized(selectedRegion, selectedStrategy);
                    }, 1000);
                    
                    log(`Current location: ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
                },
                function(error) {
                    let message = 'Failed to get location: ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            message += 'Permission denied';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message += 'Position unavailable';
                            break;
                        case error.TIMEOUT:
                            message += 'Timeout';
                            break;
                        default:
                            message += 'Unknown error';
                            break;
                    }
                    
                    if (status) {
                        status.className = 'location-status error';
                        status.textContent = '❌ ' + message;
                    }
                    
                    log('Geolocation error: ' + message);
                },
                options
            );
        }

        function geocodeLocation(locationName) {
            return new Promise((resolve, reject) => {
                log('Geocoding location: ' + locationName);
                
                const coordPattern = /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/;
                const coordMatch = locationName.match(coordPattern);
                
                if (coordMatch) {
                    const lat = parseFloat(coordMatch[1]);
                    const lng = parseFloat(coordMatch[2]);
                    if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        resolve({ lat, lng, display_name: `${lat}, ${lng}` });
                        return;
                    }
                }
                
                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationName)}&limit=1`)
                    .then(response => response.json())
                    .then(data => {
                        if (data && data.length > 0) {
                            const result = data[0];
                            resolve({
                                lat: parseFloat(result.lat),
                                lng: parseFloat(result.lon),
                                display_name: result.display_name
                            });
                        } else {
                            reject(new Error('Location not found'));
                        }
                    })
                    .catch(error => {
                        log('Geocoding error: ' + error.message);
                        reject(error);
                    });
            });
        }

        function updateLocation() {
            const locationInput = document.getElementById('location');
            const locationValue = locationInput ? locationInput.value.trim() : '';
            
            if (!locationValue) {
                showWarning('Please enter a location');
                return;
            }
            
            log('Updating location to: ' + locationValue);
            
            const updateBtn = document.getElementById('update-location');
            let originalText = 'Update Location';
            if (updateBtn) {
                originalText = updateBtn.textContent;
                updateBtn.innerHTML = '<span class="loading"></span>Loading...';
                updateBtn.disabled = true;
                updateBtn.classList.add('loading');
            }
            
            geocodeLocation(locationValue)
                .then(result => {
                    gameState.center = { lat: result.lat, lng: result.lng };
                    
                    if (gameState.map) {
                        gameState.map.setView([result.lat, result.lng], 12);
                        updateGameArea();
                    }
                    
                    if (locationInput) {
                        locationInput.value = result.display_name.split(',').slice(0, 2).join(',');
                    }
                    
                    log('Location updated successfully to: ' + result.lat + ', ' + result.lng);
                    
                    setTimeout(() => {
                        const regionSelect = document.getElementById('region-select');
                        const strategySelect = document.getElementById('loading-strategy');
                        
                        const selectedRegion = regionSelect ? regionSelect.value : 'south-kanto';
                        const selectedStrategy = strategySelect ? strategySelect.value : 'immediate';
                        
                        loadRegionalRoadsOptimized(selectedRegion, selectedStrategy);
                    }, 500);
                })
                .catch(error => {
                    showWarning('Could not find location: ' + locationValue + '. Please try a different location.');
                    log('Location update failed: ' + error.message);
                })
                .finally(() => {
                    if (updateBtn) {
                        updateBtn.textContent = originalText;
                        updateBtn.disabled = false;
                        updateBtn.classList.remove('loading');
                    }
                });
        }

        function updateDataStatus() {
            const statusDiv = document.getElementById('data-status');
            if (statusDiv) {
                // Check for GitHub KML data first
                if (gameState.difficulty === 'user-created-tokyo' && gameState.githubKmlLoaded && gameState.githubKmlData.length > 0) {
                    const breakdown = getStreetBreakdownByDifficulty();
                    
                    statusDiv.innerHTML = `
                        <div>✅ GitHub KMLデータ読み込み完了！</div>
                        <div style="font-size: 0.7rem; margin-top: 0.3rem; color: #ccc;">
                            ${gameState.githubKmlData.length} roads from daytimegufo/Street_Sensei
                        </div>
                        <div style="font-size: 0.65rem; margin-top: 0.2rem;">
                            Tourist: ${breakdown.tourist} | Resident: ${breakdown.resident} | Taxi: ${breakdown.taxi}
                        </div>
                    `;
                    statusDiv.style.background = '#2d5a2d';
                } else if (gameState.streetData && gameState.streetData.length > 0) {
                    const source = gameState.streetData[0]?.source || 'fallback';
                    const isRegional = source === 'overpass-regional';
                    
                    if (isRegional) {
                        const completeRoads = gameState.streetData.filter(r => r.isComplete).length;
                        const breakdown = getStreetBreakdownByDifficulty();
                        const regionName = currentRegionalConfig?.name || '地域';
                        const strategyName = currentLoadingStrategy?.name || '標準';
                        
                        const fromCache = gameState.streetData.some(r => r.cached === true);
                        const cacheIcon = fromCache ? '💾' : '🌐';
                        
                        const bgStatus = backgroundLoadingActive ? '⏳ 追加読み込み中' : '';
                        
                        statusDiv.innerHTML = `
                            <div>${cacheIcon} ${regionName}道路ネットワーク (${strategyName})</div>
                            <div style="font-size: 0.7rem; margin-top: 0.3rem; color: #ccc;">
                                ${gameState.streetData.length} roads (${completeRoads} complete) ${bgStatus}
                            </div>
                            <div style="font-size: 0.65rem; margin-top: 0.2rem;">
                                Tourist: ${breakdown.tourist} | Resident: ${breakdown.resident} | Taxi: ${breakdown.taxi}
                            </div>
                        `;
                        statusDiv.style.background = '#2d5a2d';
                    } else {
                        const breakdown = getStreetBreakdownByDifficulty();
                        
                        statusDiv.innerHTML = `
                            <div>✅ ${gameState.streetData.length} streets loaded (${source === 'overpass' ? 'OSM data' : 'sample data'})</div>
                            <div style="font-size: 0.7rem; margin-top: 0.3rem;">
                                Tourist: ${breakdown.tourist} | Resident: ${breakdown.resident} | Taxi: ${breakdown.taxi}
                            </div>
                        `;
                        statusDiv.style.background = source === 'overpass' ? '#2d5a2d' : '#5a4d2d';
                    }
                } else {
                    // Show different message for user-created mode
                    if (gameState.difficulty === 'user-created-tokyo') {
                        statusDiv.innerHTML = `
                            <div>🔄 GitHub KMLデータを自動読み込み中...</div>
                            <div style="font-size: 0.7rem; margin-top: 0.3rem; color: #ccc;">
                                daytimegufo/Street_Sensei リポジトリから東京都通称道路名を取得
                            </div>
                            <div style="font-size: 0.65rem; margin-top: 0.2rem;">
                                バックグラウンドで自動実行中
                            </div>
                        `;
                        statusDiv.style.background = '#5a4d2d';
                    } else {
                        const strategyDesc = currentLoadingStrategy?.description || '';
                        
                        statusDiv.innerHTML = `
                            <div>⚠️ 道路データが読み込まれていません</div>
                            <div style="font-size: 0.7rem; margin-top: 0.3rem; color: #ccc;">
                                選択中: ${currentLoadingStrategy?.name || '即座開始'}
                            </div>
                            <div style="font-size: 0.65rem; margin-top: 0.2rem;">
                                上の「Load Regional Roads」ボタンで読み込み開始
                            </div>
                        `;
                        statusDiv.style.background = '#5a2d2d';
                    }
                }
            }
        }

        function getStreetBreakdownByDifficulty() {
            if (!gameState.streetData) return { tourist: 0, resident: 0, taxi: 0 };
            
            const tourist = gameState.streetData.filter(q => q.importance >= 80).length;
            const resident = gameState.streetData.filter(q => q.importance >= 60).length;
            const taxi = gameState.streetData.filter(q => q.importance >= 40).length;
            
            return { tourist, resident, taxi };
        }

        function startGame() {
            try {
                log('Starting game...');
                
                // Check for data requirements based on difficulty
                if (gameState.currentMode === 'street' && gameState.difficulty === 'user-created-tokyo') {
                    if (!gameState.githubKmlLoaded || !gameState.githubKmlData || gameState.githubKmlData.length === 0) {
                        showWarning('GitHub KMLデータの読み込みが完了していません。少々お待ちください。');
                        return;
                    }
                    // Use GitHub KML data for user-created mode
                    gameState.streetData = gameState.githubKmlData;
                } else if (gameState.currentMode === 'street' && (!gameState.streetData || gameState.streetData.length === 0)) {
                    showWarning('Street mode requires data to be loaded first. Please click "Load Regional Roads" before starting the game.');
                    return;
                }
                
                gameState.isPlaying = true;
                gameState.score = 0;
                gameState.streak = 0;
                gameState.totalQuestions = 0;
                gameState.askedQuestions = [];
                
                const challengeSection = document.getElementById('challenge-section');
                const startBtn = document.getElementById('start-game');
                
                if (challengeSection) {
                    challengeSection.classList.remove('hidden');
                }
                if (startBtn) {
                    startBtn.style.display = 'none';
                }
                
                updateMobileControls();
                
                if (gameState.map) {
                    gameState.map.invalidateSize();
                    setTimeout(() => {
                        gameState.map.invalidateSize();
                    }, 100);
                }
                
                setTimeout(() => {
                    if (gameState.showLabels) {
                        toggleLabels();
                    }
                }, 300);
                
                if (gameState.map) {
                    gameState.map.dragging.enable();
                    gameState.map.touchZoom.enable();
                    gameState.map.doubleClickZoom.enable();
                    gameState.map.scrollWheelZoom.enable();
                    gameState.map.boxZoom.enable();
                    gameState.map.keyboard.enable();
                }
                
                nextQuestion();
                updateUI();
                
                log('Game started successfully - map interaction enabled');
            } catch (error) {
                log('Error starting game: ' + error.message);
                console.error('Start game error:', error);
            }
        }

        function filterQuestionsByDifficulty(questions) {
            if (!questions || questions.length === 0) return [];
            
            let filtered = questions.filter(q => {
                const point = q.points[0][0];
                return isWithinGameArea(point.lat, point.lng);
            });
            
            let importanceFiltered;
            
            if (gameState.difficulty === 'user-created-tokyo') {
                // For GitHub KML data, use all roads regardless of importance
                // since they are curated and high-quality
                importanceFiltered = filtered;
                log(`User-created Tokyo mode: Using all ${importanceFiltered.length} GitHub KML roads`);
                
            } else if (gameState.difficulty === 'tourist') {
                importanceFiltered = filtered.filter(q => q.importance >= 80);
                log(`Tourist mode: ${importanceFiltered.length} streets with importance >= 80`);
                
                if (importanceFiltered.length < 10) {
                    importanceFiltered = filtered.filter(q => q.importance >= 70);
                    log(`Tourist mode (relaxed): ${importanceFiltered.length} streets with importance >= 70`);
                }
                if (importanceFiltered.length < 5) {
                    importanceFiltered = filtered.filter(q => q.importance >= 60);
                    log(`Tourist mode (very relaxed): ${importanceFiltered.length} streets with importance >= 60`);
                }
                
            } else if (gameState.difficulty === 'resident') {
                importanceFiltered = filtered.filter(q => q.importance >= 60);
                log(`Resident mode: ${importanceFiltered.length} streets with importance >= 60`);
                
                if (importanceFiltered.length < 20) {
                    importanceFiltered = filtered.filter(q => q.importance >= 50);
                    log(`Resident mode (relaxed): ${importanceFiltered.length} streets with importance >= 50`);
                }
                
            } else {
                importanceFiltered = filtered.filter(q => q.importance >= 40);
                log(`Taxi Driver mode: ${importanceFiltered.length} streets with importance >= 40`);
                
                if (importanceFiltered.length < 50) {
                    importanceFiltered = filtered.filter(q => q.importance >= 30);
                    log(`Taxi Driver mode (relaxed): ${importanceFiltered.length} streets with importance >= 30`);
                }
            }
            
            if (importanceFiltered.length === 0) {
                log(`No streets found for ${gameState.difficulty} difficulty, using top 20 streets`);
                importanceFiltered = filtered.slice(0, 20);
            }
            
            importanceFiltered.sort((a, b) => b.importance - a.importance);
            
            const maxPoolSize = {
                'user-created-tokyo': 200, // Allow more questions for curated data
                'tourist': 50,
                'resident': 150, 
                'taxi-driver': 300
            };
            
            const finalFiltered = importanceFiltered.slice(0, maxPoolSize[gameState.difficulty] || 150);
            
            log(`Final filtered result for ${gameState.difficulty}: ${finalFiltered.length} streets`);
            if (finalFiltered.length > 0) {
                log(`Importance range: ${finalFiltered[finalFiltered.length-1].importance} - ${finalFiltered[0].importance}`);
            }
            
            return finalFiltered;
        }

        // Parse coordinate string from KML
        function parseCoordinateString(coordsText) {
            const coordinates = [];
            const lines = coordsText.trim().split(/\s+/);
            
            for (const line of lines) {
                const parts = line.split(',');
                if (parts.length >= 2) {
                    const lng = parseFloat(parts[0]);
                    const lat = parseFloat(parts[1]);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        coordinates.push({ lat, lng });
                    }
                }
            }
            
            return coordinates;
        }

        function calculateSegmentLength(points) {
            if (points.length < 2) return 0;
            
            let totalLength = 0;
            for (let i = 1; i < points.length; i++) {
                totalLength += calculateSimpleDistance(
                    points[i-1].lat, points[i-1].lng,
                    points[i].lat, points[i].lng
                );
            }
            return totalLength;
        }

        function calculateSimpleDistance(lat1, lng1, lat2, lng2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Game logic functions (continuing with the rest of the implementation)
        function nextQuestion() {
            try {
                log('Loading next question...');
                
                clearGameElements();
                gameState.totalQuestions++;
                
                gameState.timer = 30;
                startTimer();

                generateQuestion();
                
                const distanceDisplay = document.getElementById('distance-display');
                const nextBtn = document.getElementById('next-question');
                const showAnswerBtn = document.getElementById('show-answer');
                const multipleChoice = document.getElementById('multiple-choice');
                
                if (distanceDisplay) distanceDisplay.classList.add('hidden');
                if (nextBtn) nextBtn.classList.add('hidden');
                if (showAnswerBtn) showAnswerBtn.classList.remove('hidden');
                if (multipleChoice) multipleChoice.classList.add('hidden');
                
                if (gameState.currentMode === 'reverse') {
                    showReverseChallenge();
                }
                
                updateUI();
                updateMobileControls();
                
                log('Next question loaded');
            } catch (error) {
                log('Error loading next question: ' + error.message);
                console.error('Next question error:', error);
            }
        }

        function generateQuestion() {
            try {
                let questions;
                
                switch (gameState.currentMode) {
                    case 'facility':
                        questions = [...facilityQuestions, ...gameState.customProblems.filter(p => p.type === 'facility')];
                        break;
                    case 'intersection':
                        questions = [...intersectionQuestions, ...gameState.customProblems.filter(p => p.type === 'intersection')];
                        break;
                    case 'reverse':
                        questions = [...facilityQuestions, ...intersectionQuestions, ...gameState.customProblems.filter(p => p.type !== 'street')];
                        break;
                    default:
                        const streetQuestions = gameState.streetData || [];
                        const customStreets = gameState.customProblems.filter(p => p.type === 'street');
                        questions = [...streetQuestions, ...customStreets];
                        
                        if (questions.length === 0) {
                            showWarning('No street data loaded yet. Please click "Load Regional Roads" to get actual OpenStreetMap data.');
                            return;
                        }
                }

                const filteredQuestions = filterQuestionsByDifficulty(questions);
                
                const availableQuestions = filteredQuestions.filter(q => 
                    !gameState.askedQuestions.some(asked => asked.name === q.name)
                );
                
                let selectedQuestion;
                if (availableQuestions.length > 0) {
                    selectedQuestion = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
                } else if (filteredQuestions.length > 0) {
                    gameState.askedQuestions = [];
                    selectedQuestion = filteredQuestions[Math.floor(Math.random() * filteredQuestions.length)];
                } else {
                    selectedQuestion = questions[Math.floor(Math.random() * questions.length)];
                }
                
                if (!selectedQuestion) {
                    showWarning('No questions available. Please load street data first.');
                    return;
                }
                
                gameState.currentQuestion = selectedQuestion;
                gameState.askedQuestions.push(selectedQuestion);
                
                const questionText = document.getElementById('question-text');
                const questionType = document.getElementById('question-type');
                
                if (questionText) {
                    questionText.textContent = gameState.currentMode === 'reverse' ? 
                        `強調表示された場所は何ですか？` : 
                        `見つけてください: ${gameState.currentQuestion.name}`;
                }
                
                if (questionType) {
                    questionType.textContent = `${getModeName(gameState.currentMode)}チャレンジ`;
                }
                
                log('Question generated: ' + gameState.currentQuestion.name);
                
            } catch (error) {
                log('Error generating question: ' + error.message);
                console.error('Generate question error:', error);
            }
        }

        // Continue with remaining functions
        function showWarning(message) {
            showMessage(message, 'warning-message');
        }

        function showSuccess(message) {
            showMessage(message, 'success-message');
        }

        function showError(message) {
            showMessage(message, 'error-message');
        }

        function showInfo(message) {
            showMessage(message, 'info-message');
        }

        function showMessage(message, className) {
            const sidebar = document.querySelector('.sidebar');
            const messageDiv = document.createElement('div');
            messageDiv.className = className;
            messageDiv.textContent = message;
            sidebar.insertBefore(messageDiv, sidebar.firstChild);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        function getModeName(mode) {
            const names = {
                'street': '道路',
                'facility': '施設',
                'intersection': '交差点',
                'reverse': '逆'
            };
            return names[mode] || mode;
        }

        function updateRangeDisplay() {
            const display = document.getElementById('range-display');
            if (display) {
                display.textContent = `${gameState.range} km`;
            }
        }

        function updateImportanceDisplay() {
            const slider = document.getElementById('problem-importance');
            const display = document.getElementById('importance-display');
            if (slider && display) {
                display.textContent = slider.value;
            }
        }

        function clearGameElements() {
            try {
                clearUserMarkers();
                if (gameState.streetLayer) gameState.streetLayer.clearLayers();
                if (gameState.facilityLayer) gameState.facilityLayer.clearLayers();
                if (gameState.map) gameState.map.closePopup();
            } catch (error) {
                log('Error clearing game elements: ' + error.message);
            }
        }

        function clearUserMarkers() {
            try {
                if (gameState.userMarker && gameState.map) {
                    gameState.map.removeLayer(gameState.userMarker);
                    gameState.userMarker = null;
                }
                if (gameState.correctMarker && gameState.map) {
                    gameState.map.removeLayer(gameState.correctMarker);
                    gameState.correctMarker = null;
                }
            } catch (error) {
                log('Error clearing markers: ' + error.message);
            }
        }

        function startTimer() {
            try {
                stopTimer();
                gameState.timerInterval = setInterval(() => {
                    gameState.timer--;
                    updateTimer();
                    
                    if (gameState.timer <= 0) {
                        handleTimeout();
                    }
                }, 1000);
            } catch (error) {
                log('Error starting timer: ' + error.message);
            }
        }

        function stopTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
        }

        function handleTimeout() {
            try {
                stopTimer();
                gameState.streak = 0;
                
                if (gameState.currentMode === 'reverse') {
                    document.querySelectorAll('.choice-button').forEach(btn => {
                        btn.disabled = true;
                        if (btn.textContent === gameState.currentQuestion.name) {
                            btn.classList.add('correct');
                        }
                    });
                } else {
                    showAnswer();
                }
                
                updateUI();
                const nextBtn = document.getElementById('next-question');
                const mobileNext = document.getElementById('mobile-next');
                if (nextBtn) nextBtn.classList.remove('hidden');
                if (mobileNext) mobileNext.classList.remove('hidden');
                
                log('Timer expired');
            } catch (error) {
                log('Error handling timeout: ' + error.message);
            }
        }

        function updateTimer() {
            const timerEl = document.getElementById('timer');
            if (timerEl) {
                timerEl.textContent = gameState.timer;
                
                if (gameState.timer <= 5) {
                    timerEl.style.color = '#ff6b6b';
                    timerEl.classList.add('blinking');
                } else if (gameState.timer <= 10) {
                    timerEl.style.color = '#ff9800';
                    timerEl.classList.remove('blinking');
                } else {
                    timerEl.style.color = '#4CAF50';
                    timerEl.classList.remove('blinking');
                }
            }
        }

        function updateUI() {
            try {
                const scoreEl = document.getElementById('score');
                const streakEl = document.getElementById('streak');
                const totalQuestionsEl = document.getElementById('total-questions');
                
                if (scoreEl) scoreEl.textContent = gameState.score;
                if (streakEl) streakEl.textContent = gameState.streak;
                if (totalQuestionsEl) totalQuestionsEl.textContent = gameState.totalQuestions;
            } catch (error) {
                log('Error updating UI: ' + error.message);
            }
        }

        function updateMobileControls() {
            const mobileNext = document.getElementById('mobile-next');
            const mobileAnswer = document.getElementById('mobile-answer');
            const mobileEnd = document.getElementById('mobile-end');
            
            if (gameState.isPlaying) {
                if (mobileNext) mobileNext.classList.add('hidden');
                if (mobileAnswer) mobileAnswer.classList.remove('hidden');
                if (mobileEnd) mobileEnd.classList.remove('hidden');
            } else {
                if (mobileNext) mobileNext.classList.add('hidden');
                if (mobileAnswer) mobileAnswer.classList.add('hidden');
                if (mobileEnd) mobileEnd.classList.add('hidden');
            }
        }

        function isWithinGameArea(lat, lng) {
            try {
                if (typeof turf !== 'undefined') {
                    const point = turf.point([lng, lat]);
                    const center = turf.point([gameState.center.lng, gameState.center.lat]);
                    const distance = turf.distance(center, point, { units: 'kilometers' });
                    return distance <= gameState.range;
                } else {
                    const R = 6371;
                    const dLat = (lat - gameState.center.lat) * Math.PI / 180;
                    const dLng = (lng - gameState.center.lng) * Math.PI / 180;
                    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                             Math.cos(gameState.center.lat * Math.PI / 180) * Math.cos(lat * Math.PI / 180) *
                             Math.sin(dLng/2) * Math.sin(dLng/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    const distance = R * c;
                    return distance <= gameState.range;
                }
            } catch (error) {
                log('Error checking game area: ' + error.message);
                return true;
            }
        }

        // Placeholder functions for remaining functionality
        function showAnswer() { log('Show answer function placeholder'); }
        function handleMapClick(e) { log('Map click handler placeholder'); }
        function showReverseChallenge() { log('Reverse challenge placeholder'); }
        function generateMultipleChoices() { return []; }
        function handleReverseAnswer(choice, button) { log('Reverse answer handler placeholder'); }
        function endGame() { log('End game function placeholder'); }
        function resetGame() { log('Reset game function placeholder'); }
        function toggleSettings() { log('Toggle settings placeholder'); }
        function toggleLabels() { log('Toggle labels placeholder'); }
        function loadCustomProblems() { log('Load custom problems placeholder'); }

        // Global functions for editor
        window.removePoint = function() { log('Remove point placeholder'); };
        window.editProblem = function() { log('Edit problem placeholder'); };
        window.deleteProblem = function() { log('Delete problem placeholder'); };
        window.resetGame = resetGame;

        // Initialize game when page loads with multiple fallbacks
        document.addEventListener('DOMContentLoaded', function() {
            log('DOM loaded, checking dependencies...');
            
            function checkLeafletAndInit() {
                if (typeof L !== 'undefined') {
                    log('Leaflet detected, initializing game...');
                    setTimeout(initGame, 100);
                } else {
                    log('Leaflet not loaded yet, waiting...');
                    setTimeout(checkLeafletAndInit, 200);
                }
            }
            
            checkLeafletAndInit();
        });

        window.addEventListener('load', function() {
            setTimeout(() => {
                if (!gameState.isMapInitialized) {
                    log('Backup initialization triggered');
                    initGame();
                }
            }, 1000);
        });

        setTimeout(() => {
            if (!gameState.isMapInitialized) {
                log('Emergency initialization attempt...');
                if (typeof L !== 'undefined') {
                    initGame();
                } else {
                    log('ERROR: Leaflet failed to load. Please refresh the page.');
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        debugInfo.innerHTML = 'ERROR: Map library failed to load. <button onclick="location.reload()" style="background:#f44336;color:white;border:none;padding:0.5rem;border-radius:4px;margin-left:0.5rem;">Refresh Page</button>';
                        debugInfo.style.display = 'block';
                        debugInfo.style.background = '#f44336';
                    }
                }
            }
        }, 5000);

        window.addEventListener('resize', function() {
            if (gameState.map) {
                setTimeout(() => {
                    gameState.map.invalidateSize();
                    log('Map size invalidated after resize');
                }, 200);
            }
        });

        window.addEventListener('orientationchange', function() {
            log('Orientation changed, invalidating map size...');
            setTimeout(() => {
                if (gameState.map) {
                    gameState.map.invalidateSize();
                    if (window.innerWidth <= 768) {
                        gameState.map.setView(gameState.map.getCenter(), gameState.map.getZoom(), { animate: false });
                    }
                }
            }, 1000);
        });

        if ('ontouchstart' in window) {
            log('Touch device detected, applying touch optimizations...');
            
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(e) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }

        if ('onLine' in navigator) {
            window.addEventListener('online', function() {
                log('Network connection restored');
                if (!gameState.isMapInitialized) {
                    log('Attempting to reinitialize map...');
                    initGame();
                }
            });
            
            window.addEventListener('offline', function() {
                log('Network connection lost');
            });
        }

        if ('visibilityState' in document) {
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'visible') {
                    log('Page became visible, checking map state...');
                    if (gameState.map) {
                        setTimeout(() => {
                            gameState.map.invalidateSize();
                        }, 500);
                    }
                } else {
                    log('Page became hidden, pausing background operations...');
                }
            });
        }

        log('Enhanced Back of Your Hand game script loaded successfully');
        
        if (window.innerWidth <= 768) {
            log('Mobile device detected - Enhanced mobile mode enabled');
        }
    </script>
</body>
</html>